<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cpp on Материалы курсов на кафедре Технологии Программирования. ПМ-ПУ</title>
    <link>https://apmath-spbu.github.io/tags/cpp/</link>
    <description>Recent content in cpp on Материалы курсов на кафедре Технологии Программирования. ПМ-ПУ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language><atom:link href="https://apmath-spbu.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1.1. Введение в программирование</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part1/</guid>
      <description>Машинный язык Процессор компьютера не способен понимать напрямую языки программирования, такие как C++, С#, Java, Kotlin, Python и т.д. Очень ограниченный набор инструкций, которые изначально понимает процессор, называется машинным кодом (или «машинным языком»). То, как эти инструкции организованы, выходит за рамки данного введения, но стоит отметить две вещи.
Во-первых, каждая команда (инструкция) состоит только из определенной последовательности (набора) цифр: 0 и 1. Эти числа называются битами или двоичным кодом.
Например, одна команда машинного кода архитектуры ×86 выглядит следующим образом:</description>
    </item>
    
    <item>
      <title>1.2. Введение в языки программирования C и C&#43;&#43;</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part2/</guid>
      <description>Перед C++ был C. C был разработан в 1972 году Деннисом Ритчи в Bell Telephone Laboratories как системный язык программирования, т.е. язык для написания операционных систем. Основной задачей Ритчи было создание легко компилируемого минималистического языка, который предоставлял бы эффективный доступ к памяти, относительно быстро выполнялся, и на котором можно было бы писать эффективный код. Таким образом, при разработке высокоуровневого языка, был создан язык Си, который во многом относился к языкам низкого уровня, оставаясь при этом независимым от платформ, для которых мог быть написан код.</description>
    </item>
    
    <item>
      <title>1.3. Компиляция</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part3/</guid>
      <description>Программы на языке C++ следует называть name.cpp, где name заменяется именем вашей программы, а расширение .cpp сообщает компилятору (и вам тоже), что это исходный файл кода, который содержит инструкции на языке программирования C++. Ниже представлена классическая программа на C++ (файл hello.cpp):
#include &amp;lt;iostream&amp;gt;using namespace std;int main(){cout&amp;lt;&amp;lt;&amp;quot;Hello World&amp;quot;;return 0;}Перед тем как ее выполнить, данный код перевести в машинный. Процесс перевод состоит их 3 частей:</description>
    </item>
    
    <item>
      <title>1.4. Типы данных</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part4/</guid>
      <description>C++ предоставляет работу со следюущими &amp;ldquo;примитивными&amp;rdquo; типами данных:
 Примитивные Производные Пользовательские  В рамках первой лекции мы рассмотрим только примитивные типы данных. Остальные будут представлены позже. Примитивные делятся на:
 Целочисленные (Integer) - short (2 байта), int (4 байта), long (8 байт) Символ (Character) - char (1 байт) Булевский (Boolean) - bool (1 байт) - может хранить или true или false С плавающей точкой (Floating point) - float С двойной точностью (Double floating point) - double void - предствляет сущности без значения.</description>
    </item>
    
    <item>
      <title>1.5. Переменные</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part5/</guid>
      <description>При определении переменной указывается её тип. При определении можно сразу задать начальное значение (инициализация), задать несколько переменных в одной строке или просто объявить (без инициализации):
int i = 10; short j = 20; bool b = false; unsigned long l = 123123; double x = 13.5 , y = 3.1415; float z; В языке C++ есть две похожие концепции, которые новички часто путают: присваивание и инициализация. После объявления переменной, ей можно присвоить значение с помощью оператора присваивания (знак равенства =):</description>
    </item>
    
    <item>
      <title>1.6. Инструкции. Условные операторы. Циклы</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part6/</guid>
      <description>Как вы уже видели в предыдущих частях выполнение программы на C++ состоит из последовательных инстркций. Инструкции выполняются одна за другой. Тем не менее, несмотря на это, при определенных оптимизациях компилятор может попытаться съоптимизировать выполнение инстуркций и приведенный ниже пример не рекомендуется использовать на практике:
#include &amp;lt;iostream&amp;gt;using namespace std;int main(){int i = 10; i = ( i += 5) + ( i * 4);cout &amp;lt;&amp;lt; &amp;quot;i is &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; // 75return 0;}Вложенная видимость Можно объявлять блоки (с помощью фигурных скобок) и в них объявлять переменные с уже сипользованным именем.</description>
    </item>
    
    <item>
      <title>1.7. Функции</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part7/</guid>
      <description>Функция — это последовательность команд для выполнения определенного задания. Собственно ваши программы и будут из них состоять (как минимум из функции main). Сигнатра функции состоит из возвращаемого типа, имени функции и переменных данной функции (если они есть) в круглых скобках. Ключевое слово return возвращает значение из функции или выходит из нее (если тип возвращаемого значение void - то есть функция является процедурой).
#include &amp;lt;iostream&amp;gt;using namespace std;double square (double x){return x * x;}void printFinish(){cout &amp;lt;&amp;lt; &amp;quot;Finish&amp;quot;;}int main(){cout &amp;lt;&amp;lt; square(9) &amp;lt;&amp;lt; endl; // выведется 81printFinish();return 0;}Переменные объявляенные внутри функции - являются локальными для этих функций.</description>
    </item>
    
    <item>
      <title>1.8. Макросы. Ввод-вывод</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part8/</guid>
      <description>В качестве продвинутой темы первой лекции рассмотрим применение макросов в C++. Макрос можно условно назвать функцией обработки и замены программного кода: после сборки программы макросы заменяются макроопределениями. Вот как это выглядит на примере подмены функции:
#include &amp;lt;iostream&amp;gt;using namespace std;#define SUM(x, y) (x + y)int main(){int a = 5;int b = 10;int sum = SUM(a, b);cout &amp;lt;&amp;lt; sum;return 0;}Этот код преобразуется препроцессором в следующий:</description>
    </item>
    
    <item>
      <title>Основы программирования Осень 2020</title>
      <link>https://apmath-spbu.github.io/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/</guid>
      <description>В рамках курса по основам программировани в осеннем семестре будут рассматариваться основы работы с языком C++. Здесь будут выкладываться краткое содержание теоретического материала, которого должно быть достаточно для решения практических задач на платформе HackerRank - точная ссылка &amp;ldquo;приглашение&amp;rdquo; на контест будет расшарена в телеграм-группе. Материалы будут появлятся по неделям и оповещаться в телеграмм-группе.
Для получения зачета вам необходимо будет решать домашние задачи на HackerRank и получить &amp;ldquo;квалификационное&amp;rdquo; количество баллов. В течении семестра будет проведено 2 контрольные работы, результаты на которых будут учтены на экзамене.</description>
    </item>
    
  </channel>
</rss>
