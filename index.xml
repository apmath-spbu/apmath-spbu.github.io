<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Материалы курсов на кафедре Технологии Программирования. ПМ-ПУ</title>
    <link>https://apmath-spbu.github.io/</link>
    <description>Recent content on Материалы курсов на кафедре Технологии Программирования. ПМ-ПУ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Tue, 01 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://apmath-spbu.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1.1. Введение в программирование</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part1/</guid>
      <description>Машинный язык Процессор компьютера не способен понимать напрямую языки программирования, такие как C++, С#, Java, Kotlin, Python и т.д. Очень ограниченный набор инструкций, которые изначально понимает процессор, называется машинным кодом (или «машинным языком»). То, как эти инструкции организованы, выходит за рамки данного введения, но стоит отметить две вещи.
Во-первых, каждая команда (инструкция) состоит только из определенной последовательности (набора) цифр: 0 и 1. Эти числа называются битами или двоичным кодом.
Например, одна команда машинного кода архитектуры ×86 выглядит следующим образом:</description>
    </item>
    
    <item>
      <title>1.2. Введение в языки программирования C и C&#43;&#43;</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part2/</guid>
      <description>Перед C++ был C. C был разработан в 1972 году Деннисом Ритчи в Bell Telephone Laboratories как системный язык программирования, т.е. язык для написания операционных систем. Основной задачей Ритчи было создание легко компилируемого минималистического языка, который предоставлял бы эффективный доступ к памяти, относительно быстро выполнялся, и на котором можно было бы писать эффективный код. Таким образом, при разработке высокоуровневого языка, был создан язык Си, который во многом относился к языкам низкого уровня, оставаясь при этом независимым от платформ, для которых мог быть написан код.</description>
    </item>
    
    <item>
      <title>1.3. Компиляция</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part3/</guid>
      <description>Программы на языке C++ следует называть name.cpp, где name заменяется именем вашей программы, а расширение .cpp сообщает компилятору (и вам тоже), что это исходный файл кода, который содержит инструкции на языке программирования C++. Ниже представлена классическая программа на C++ (файл hello.cpp):
#include &amp;lt;iostream&amp;gt;using namespace std;int main(){cout&amp;lt;&amp;lt;&amp;quot;Hello World&amp;quot;;return 0;}Перед тем как ее выполнить, данный код перевести в машинный. Процесс перевод состоит их 3 частей:</description>
    </item>
    
    <item>
      <title>1.4. Типы данных</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part4/</guid>
      <description>C++ предоставляет работу со следюущими &amp;ldquo;примитивными&amp;rdquo; типами данных:
 Примитивные Производные Пользовательские  В рамках первой лекции мы рассмотрим только примитивные типы данных. Остальные будут представлены позже. Примитивные делятся на:
 Целочисленные (Integer) - short (2 байта), int (4 байта), long (8 байт) Символ (Character) - char (1 байт) Булевский (Boolean) - bool (1 байт) - может хранить или true или false С плавающей точкой (Floating point) - float С двойной точностью (Double floating point) - double void - предствляет сущности без значения.</description>
    </item>
    
    <item>
      <title>1.5. Переменные</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part5/</guid>
      <description>При определении переменной указывается её тип. При определении можно сразу задать начальное значение (инициализация), задать несколько переменных в одной строке или просто объявить (без инициализации):
int i = 10; short j = 20; bool b = false; unsigned long l = 123123; double x = 13.5 , y = 3.1415; float z; В языке C++ есть две похожие концепции, которые новички часто путают: присваивание и инициализация. После объявления переменной, ей можно присвоить значение с помощью оператора присваивания (знак равенства =):</description>
    </item>
    
    <item>
      <title>1.6. Инструкции. Условные операторы. Циклы</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part6/</guid>
      <description>Как вы уже видели в предыдущих частях выполнение программы на C++ состоит из последовательных инстркций. Инструкции выполняются одна за другой. Тем не менее, несмотря на это, при определенных оптимизациях компилятор может попытаться съоптимизировать выполнение инстуркций и приведенный ниже пример не рекомендуется использовать на практике:
#include &amp;lt;iostream&amp;gt;using namespace std;int main(){int i = 10; i = ( i += 5) + ( i * 4);cout &amp;lt;&amp;lt; &amp;quot;i is &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; // 75return 0;}Вложенная видимость Можно объявлять блоки (с помощью фигурных скобок) и в них объявлять переменные с уже сипользованным именем.</description>
    </item>
    
    <item>
      <title>1.7. Функции</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part7/</guid>
      <description>Функция — это последовательность команд для выполнения определенного задания. Собственно ваши программы и будут из них состоять (как минимум из функции main). Сигнатра функции состоит из возвращаемого типа, имени функции и переменных данной функции (если они есть) в круглых скобках. Ключевое слово return возвращает значение из функции или выходит из нее (если тип возвращаемого значение void - то есть функция является процедурой).
#include &amp;lt;iostream&amp;gt;using namespace std;double square (double x){return x * x;}void printFinish(){cout &amp;lt;&amp;lt; &amp;quot;Finish&amp;quot;;}int main(){cout &amp;lt;&amp;lt; square(9) &amp;lt;&amp;lt; endl; // выведется 81printFinish();return 0;}Переменные объявляенные внутри функции - являются локальными для этих функций.</description>
    </item>
    
    <item>
      <title>1.8. Макросы. Ввод-вывод</title>
      <link>https://apmath-spbu.github.io/basics/lecture1/part8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture1/part8/</guid>
      <description>В качестве продвинутой темы первой лекции рассмотрим применение макросов в C++. Макрос можно условно назвать функцией обработки и замены программного кода: после сборки программы макросы заменяются макроопределениями. Вот как это выглядит на примере подмены функции:
#include &amp;lt;iostream&amp;gt;using namespace std;#define SUM(x, y) (x + y)int main(){int a = 5;int b = 10;int sum = SUM(a, b);cout &amp;lt;&amp;lt; sum;return 0;}Этот код преобразуется препроцессором в следующий:</description>
    </item>
    
    <item>
      <title>История</title>
      <link>https://apmath-spbu.github.io/methodology/history/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/methodology/history/</guid>
      <description>Фреймворк методологии разработки программного обеспечения (SDM - Software Developer Methodology) появился только в 1960-х годах. Жизненный цикл разработки системы (SDLC - Software Development Life Cycle) можно рассматривать как старейшую формализованную методологическую основу для построения информационных систем . Основная идея SDLC заключалась в том, чтобы «продолжать разработку информационных систем очень продуманным, структурированным и методичным образом, требуя, чтобы каждый этап жизненного цикла - от зарождения идеи до доставки окончательной системы - выполнялся. выполняется жестко и последовательно «в контексте применяемой структуры.</description>
    </item>
    
    <item>
      <title>Лабораторная работа №1.</title>
      <link>https://apmath-spbu.github.io/methodology/labs/lab1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/methodology/labs/lab1/</guid>
      <description>Цель Освоить базовые принципы Agile-подхода к разработке ПО и получить практические навыки планирования Agile/scram на примере Atlassian Jira
Для выбранного варианта, необходимо провести планирование проекта по модели Agile/Scram:
 Зарегестрироваться на сайте https://www.atlassian.com/ (бесплатной версии будет достаточно) Создать проект – одному из подгруппы Добавить в проект зарегистрированных ранее участников – выполняет владелец проекта (администратор).  Проект нужно выполнять в команде из 3-4 человек (2-3 разработчика, 1 тестировщик)
Подробнее о SCRUM</description>
    </item>
    
    <item>
      <title>Модификаторы доступа</title>
      <link>https://apmath-spbu.github.io/basics/lecture5/accessmodifier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture5/accessmodifier/</guid>
      <description>Рассматривая тему конструктора я уже привел пример с модифкатором досутупа private, но мы не разбирали детально.Модификаторы доступа позволяют ограничивать доступ к методам и полям класса. В C++ существует 3 основных модификатора доступа, но сейчас я перечислю только 2 (с третьим познакомимся чуть позже):
 private - все объекты следующие за этой меткой являются закрытми, то есть доступные только внутри класса. Доступ извне запрещен. public - все объекты следующие за этой меткой являются открытыми, фактически представляют интерфейс класса.</description>
    </item>
    
    <item>
      <title>Наследование/Композиция/Аггрегация</title>
      <link>https://apmath-spbu.github.io/basics/lecture6/composition-aggregation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture6/composition-aggregation/</guid>
      <description>Поговорим еще немного о наследовании и их связи на конкретном примере геометрических фигур квадрата и прямоугольника. Когда мы готовы применить наследование мы должны применять принцип &amp;ldquo;is a&amp;rdquo; отношение. Геометрически квадрат — это специализация прямоугольника: все квадраты — прямоугольники, но не все прямоугольники — квадраты. Все объекты в классе «Квадрат» являются прямоугольниками, у которых длина равна ширине. Другими словами &amp;ldquo;Square is a Rectangle&amp;rdquo;, но прямоугольник не всегда является квадратом. Получаем следующую иерархию: classDiagramShape class Shape { // .</description>
    </item>
    
    <item>
      <title>Ссылки</title>
      <link>https://apmath-spbu.github.io/basics/lecture3/references/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture3/references/</guid>
      <description>Прежде чем описывать ссылки, давайте вспомним прошлую лекцию и распишем недостатки указателей (возможно список не полон)
Недостатки указателей  Использование указателей синтаксически загрязняет код и усложняет его понимание. (Приходится использовать операторы * и &amp;amp;) Указатели могут быть неинициализированными (что придит к некорректному исполнению кода). Указатель может быть нулевым, и его нужно прверять на равенству нулю при использовании. Арифметика указателей может сделать из корректного указателя некорректный, так как достаточно легко &amp;ldquo;промахнуться&amp;rdquo;.  Все это привело к тому, что в языке С++ появилось более дружелюбный тип данных, лишенных данных недостатков.</description>
    </item>
    
    <item>
      <title>Стек вызовов</title>
      <link>https://apmath-spbu.github.io/basics/lecture2/callstack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture2/callstack/</guid>
      <description>Стек вызовов — это сегмент данных, используемый для хранения локальных переменных и временных значений. Не стоит путать стек с одноимённой структурой данных, у стека в C++ можно обратиться к произвольной ячейке. Стек выделяется при запуске программы и обычно небольшой по размеру (4Мб). Все функции хранят свои локальные переменные на стеке. При выходе из функции соответствующая область стека объявляется свободной. Промежуточные значения, возникающие при вычислении сложных выражений, также хранятся на стеке.</description>
    </item>
    
    <item>
      <title>Структура</title>
      <link>https://apmath-spbu.github.io/basics/lecture4/struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture4/struct/</guid>
      <description>Давайте предстваим, что перед нами стоит задача вычисления расстояния между двумя точками. Наверняка для этого в первом приближении можно написать такое объявление функции
double length(double x1, double y1, double x2, double y2); где x1, y1 - координаыты первой точки, x2, y2 - второй. Налицо излишняя многословность в объявлении координат точек. Что если представить точку как объект из координат по x и y? Для этого в языке С++ есть специальная струкрутура данных - струртура (struct).</description>
    </item>
    
    <item>
      <title>Диначеская память</title>
      <link>https://apmath-spbu.github.io/basics/lecture3/dynamic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture3/dynamic/</guid>
      <description>Язык С++ поддерживает два основных типа выделения памяти:
 Статическое выделение памяти выполняется для статических и глобальных переменных. Память выделяется один раз (при запуске программы) и сохраняется на протяжении работы всей программы. Динамическое выделение памяти.  Как статическое выделение памяти имеют два общих свойства:
 Размер переменной/массива должен быть известен во время компиляции. Выделение и освобождение памяти происходит автоматически (когда переменная создается/уничтожается).  В некоторых случааях этого достаточно. Но в большинстве мы заранее не можем сказать какой длины будет считанная строка, или какой длины мыссив нам нужно для наших задач.</description>
    </item>
    
    <item>
      <title>Жизненный цикл ПО</title>
      <link>https://apmath-spbu.github.io/methodology/sdlc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/methodology/sdlc/</guid>
      <description>Жизненный цикл программного обеспечения (SDLC) – это условная схема, включающая отдельные этапы, которые представляют стадии процесса создания ПО. При этом, на каждом этапе выполняются разные действия.
Цикл разработки предлагает шаблон, использование которого облегчает проектирование, создание и выпуск качественного программного обеспечения. Это методология, определяющая процессы и средства, необходимые для успешного завершения проекта.
Хотя реализация принципов построения модели жизненного цикла для разных компаний может существенно отличаться, существуют стандарты, такие как ISO/IEC 12207, определяющие принятые практики разработки и сопровождения программного обеспечения.</description>
    </item>
    
    <item>
      <title>Инкапсуляция</title>
      <link>https://apmath-spbu.github.io/basics/lecture4/incapsulation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture4/incapsulation/</guid>
      <description>При первом знакомстве со стуртурами мы получили возможность объединять данные, оставляя их доступными к изменению извне. Также функция length было объявленная как функция в объекту Segment. Что если поместить реализацию этой функции в структуру, тем самым сделав ее неотъемлемой частью структуры и &amp;ldquo;скрыв&amp;rdquo; из глобального списка функций (другими словами зачем нам эта отдельная глобальная функция, если она применима только Segment)? Реализовать это можно следующим образом (поместив реализация функции в тело struct)</description>
    </item>
    
    <item>
      <title>Переопределение операторов</title>
      <link>https://apmath-spbu.github.io/basics/lecture6/operator-overriding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture6/operator-overriding/</guid>
      <description>Вспомним еще раз весь список операторов в C++
 Арифметические:  Унарные: (префиксные/постфиксные) + - ++ &amp;ndash; Бинарные: + - * / % += -= /= %=   Битовые:  Унарные: ~ Бинарные: &amp;amp; | ^ &amp;amp;= |= ^= &amp;raquo; &amp;laquo;   Логические:  Унарные: ! Бинарные: &amp;amp; | &amp;amp;&amp;amp; || Сравнения: == != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;=   Присваивания: = Тернарный: ?: Специальные: , . :: Скобки: [] () Оператор приведения: (type) Доступа: -&amp;gt;  Все операторы, за исключением ?</description>
    </item>
    
    <item>
      <title>Полиморфизм</title>
      <link>https://apmath-spbu.github.io/basics/lecture5/polymorphism/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture5/polymorphism/</guid>
      <description>Полиморфизм - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач. Целью полиморфизма, применительно к объектно-ориентированному программированию, является использование одного имени для задания общих для класса действий. В С++ можно использовать одно имя функции для множества различных действий. Это называется перегрузкой функций (function overloading).
Фактически, мы уже познакомились с эти понятием разбирая структруру. Есть 3 метода и каждый из них принмает различные входные данные (как по количеству, так и по типу):</description>
    </item>
    
    <item>
      <title>Указатели</title>
      <link>https://apmath-spbu.github.io/basics/lecture2/pointers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture2/pointers/</guid>
      <description>Указатель — это переменная, значением которой является адрес ячейки памяти (оперативной). Указатели объявляются точно так же, как и обычные переменные, только со звёздочкой (причем, здвездочка по отношению к переменной и типом может быть на любом расстоянии). Указатели являются типизированными.
int* p; // указатель на переменную типа int bool * pb; // указатель на переменную типа bool double *p2; // указатель на переменную типа double char *p3, *p4; // 2 указателя на переменную типа char Сейчас мы только что объявили указатели, но не присвоили им никакого значения.</description>
    </item>
    
    <item>
      <title>Mutable</title>
      <link>https://apmath-spbu.github.io/basics/lecture4/mutable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture4/mutable/</guid>
      <description>Константные функции В рассматриваемой структуре Segment функция length очевидно не должна изменять внутренние поля стрктуры, а только возврщать значение основываясь на текущих внутренних значениях. Это часто бывает полезно указать, что данный метод является своего рода &amp;ldquo;расширением&amp;rdquo; или предоставлением какой-либо информации основываясь только на текущем состоянии структуры. Такие метод можно пометить ключевым словом const сделав функцию константой:
struct Segment { Point p1; Point p2; double length() const { double dx = p1.</description>
    </item>
    
    <item>
      <title>Массивы</title>
      <link>https://apmath-spbu.github.io/basics/lecture2/arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture2/arrays/</guid>
      <description>Массив — это набор однотипных элементов, расположенных в памяти друг за другом, доступ к которым осуществляется по индексу. Массивы в C++ можно задавать статически и динамически (о последнем позже).
Статический массив можно объявить следующим образом:
int m[10] = {1, 2, 3, 4, 5}; // массив 1 2 3 4 5 0 0 0 0 0 Обратитите внимание, что мы выделили место под 19 элементов, но инициализировали только 5; в остальные ячейки записано значение по умолчанию для int.</description>
    </item>
    
    <item>
      <title>Многомерные массивы</title>
      <link>https://apmath-spbu.github.io/basics/lecture3/multiplearrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture3/multiplearrays/</guid>
      <description>Помимо обычных массивов в C++ предоставляет возможность создавать и многомерные. Рассмотри на примере двумерного массива. Двумерный массив – объект данных T a[N][M], который:
 Содержит N последовательно расположенных в памяти строк по M элементов типа T в каждой; В общем и целом инициализируется аналогично одномерным массивам; По характеристикам выравнивания идентичен объекту T a[N * M], что сводит его двумерный характер к удобному умозрительному приему, упрощающему обсуждение и визуализацию порядка размещения данных  Массивы размерности больше двух считаются многомерными, при этом (N+1)-мерные массивы индуктивно определяются как линеаризованные массивы N-мерных массивов, для которых справедливо все сказанное об одно- и двумерных массивах.</description>
    </item>
    
    <item>
      <title>Модели разработки ПО</title>
      <link>https://apmath-spbu.github.io/methodology/sdm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/methodology/sdm/</guid>
      <description>Рассмотрим самые основые — модели разработки ПО (как часть жизненного цикла ПО). При этом сразу подчеркнём, что разработка ПО является лишь частью жизненного цикла ПО, и здесь мы говорим именно о разработке.
Моделей разработки ПО много, но, в общем случае, классическими можно считать каскадную, v-образную, итерационную, инкрементальную, спиральную и гибкую.
Знать и понимать модели разработки ПО необходимо затем, чтобы уже с первых дней работы понимать, что происходит вокруг, что, зачем и почему Вы делаете.</description>
    </item>
    
    <item>
      <title>Наследование</title>
      <link>https://apmath-spbu.github.io/basics/lecture5/inheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture5/inheritance/</guid>
      <description>Наследование - это механизм создания нового класса на основе уже существующего. При этом к существующему классу могут быть добавлены новые элементы (данные и функции), либо существующие функции могут быть изменены. Наследование содействует повторному использованию атрибутов и методов класса, а значит, делает процесс разработки ПО более эффективным. Возникающие между классами A и B отношения наследования позволяют, например говорить, что:
 Класс А является базовым (base) или родительским классом, классом-предком, суперклассом (superclass) Класс B является производным (derived) или дочерним классом, классом-потомком, подклассом (subclass)  Отношения наследования связывают классы в иерархию наследования, вид которой зависит от числа базовых классов у каждого производного:</description>
    </item>
    
    <item>
      <title>Статические переменные</title>
      <link>https://apmath-spbu.github.io/basics/lecture6/static/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture6/static/</guid>
      <description>В С++ различают локальные и глобальные переменные. Глобальные переменные статичны по определению. Но в C++ можно ввести и статическую локальную переменную. Статическа локальная переменная – это глобальная переменная, доступная только в пределах функции. Время жизни – от первого вызова функции до конца программы.
#include &amp;lt;iostream&amp;gt;using namespace std; int next(int start = 0) { static int k = start; return k++; } int main() { cout &amp;lt;&amp;lt; next(5); cout &amp;lt;&amp;lt; next(4); cout &amp;lt;&amp;lt; next(3); cout &amp;lt;&amp;lt; next(2); cout &amp;lt;&amp;lt; next(1); return 0; } // 56789 Статические поля класса Статические поля класса – это глобальные переменные, определенные внутри класса.</description>
    </item>
    
    <item>
      <title>Const</title>
      <link>https://apmath-spbu.github.io/basics/lecture3/const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture3/const/</guid>
      <description>В С/С++ есть простой модификатор, который делает переменную постоянной (константной).
const int value = 5; value = 8; // не получится. ощибка Порой бывают случаи, что нам нужно гарантировать, что указатель или ссылку, что мы передаем в функцию не смогу подменить на другую переменную (по ошибке или намеренно), или для гарантии того, что функция случайно не изменит значение переданного аргумента или все вместе. Для этого используются константыне модификации указателей и ссылок.</description>
    </item>
    
    <item>
      <title>Inline и друзья</title>
      <link>https://apmath-spbu.github.io/basics/lecture6/inline-friends/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture6/inline-friends/</guid>
      <description>Inline В некоторых случая можно дать совет компилятору встроить реализацию функции в местах вызова данной функции. Таким образом функция не будет вызвана, а ее тело будет скопировано и встравлено в место вызова, ресурсы, которые могли бы быть потрачены на вызов этой функции, — сохраняются! Минусом является лишь увеличение компилируемого кода за счет того, что встроенная функция раскрывается в коде при каждом вызове (особенно если она длинная и/или её вызывают много раз).</description>
    </item>
    
    <item>
      <title>SCRUM</title>
      <link>https://apmath-spbu.github.io/methodology/scrum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/methodology/scrum/</guid>
      <description>Scrum (Скрам) — методология управления проектами, активно применяющаяся при разработке информационных систем для гибкой разработки программного обеспечения. Scrum чётко делает акцент на качественном контроле процесса разработки. Скрам представляет из себя набор принципов, на которых строится процесс разработки, позволяющий в жёстко фиксированные и небольшие по времени итерации, называемые спринтами (sprints), предоставлять конечному пользователю работающее ПО с новыми возможностями, для которых определён наибольший приоритет. При этом строго фиксированная небольшая длительность спринта придаёт процессу разработки предсказуемость и гибкость.</description>
    </item>
    
    <item>
      <title>this</title>
      <link>https://apmath-spbu.github.io/basics/lecture4/this/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture4/this/</guid>
      <description>В некоторых случаях имена полей класса могут совпадать с переданными через функцию. Для возможности различать имена полей классов можно ипользовать ключевое слово this которое является ссылкой на текущий экземпляр этого класса:
struct Point { double x; double y; void shift(double x, double y) { this-&amp;gt;x += x; this-&amp;gt;y +=y; } }; </description>
    </item>
    
    <item>
      <title>Виртуальные функции</title>
      <link>https://apmath-spbu.github.io/basics/lecture5/virtualfunctions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture5/virtualfunctions/</guid>
      <description>При построении иерархии классов нередки случаи, когда базовая функцианальность должна быть изменена/дополнена. Например код предыдущей секции:
class Base { public: void hi() { cout &amp;lt;&amp;lt; &amp;#34;Hi, I&amp;#39;m base class&amp;#34; &amp;lt;&amp;lt; endl; } }; class Derived : public Base { public: void hi() { cout &amp;lt;&amp;lt; &amp;#34;Hi, I&amp;#39;m derived class&amp;#34; &amp;lt;&amp;lt; endl; } }; // ...  Derived d; Base b = d; d.hi(); // &amp;#34;Hi, I&amp;#39;m derived class&amp;#34; b.hi(); // &amp;#34;Hi, I&amp;#39;m base class&amp;#34; Наша из экземпляра наследника вызвать переопределенную функцию.</description>
    </item>
    
    <item>
      <title>Конструирование ПО</title>
      <link>https://apmath-spbu.github.io/methodology/constructing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/methodology/constructing/</guid>
      <description>Основные тезисы:
Конструирование ПО - крупная чать процесса разработки ПО. Вот такие состовляющие разработки ПО, которые были определены за последние 35 лет:
 определение проблемы выработка требований создание плана конструирования разработка архитектуры ПО, или высокоуровневое проектирование детальное проектирование кодирование и отладка блочное тестирование интеграционное тестирование интеграция тестрование системы сопровождение  Конкретные задачи, связанные с конструированием:
 проверка выполнения условий определение способов последующего тестирования проектирование и написание классов и интерфейсов создание и присвоение имен переменным и именованным константам выбор управляющих структур и организация блоков команд блочное тестирование, интеграционное тестирование, отладка ревью, форматирование, комментирование кода  Результат конструирования - исходный код.</description>
    </item>
    
    <item>
      <title>Строки</title>
      <link>https://apmath-spbu.github.io/basics/lecture2/strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture2/strings/</guid>
      <description>C-style строки В языке C строки представляли как массивы char-ов, которые заканчиваются специальным символом \0 (на самом деле, это просто символ с номером 0).
C++ сохраняет (в основном) совместимость с языком C, и поэтому поддерживает работу с C-style строками.
char s[15] = &amp;#34;C-style string&amp;#34;; char s2[] = &amp;#34;C-style string&amp;#34;; // размер массива 15 char-ов Знать о строках C-style стоит, так как они используются не так уж и редко, но использовать их без веской на то причины не рекомендуется</description>
    </item>
    
    <item>
      <title>Vector</title>
      <link>https://apmath-spbu.github.io/basics/lecture2/vector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture2/vector/</guid>
      <description>Рассмотрим первый контейнер - альтернативу массиву - vector. Представленный в C++03, vector — это динамический массив, который может сам управлять выделенной для себе памятью. Это означает, что вы можете создавать массивы, длина которых задается во время выполнения. vector находится в заголовочном файле vector
#include &amp;lt;vector&amp;gt;using namespace std; // Нет необходимости указывать длину при инициализации vector&amp;lt;int&amp;gt; array; vector&amp;lt;int&amp;gt; array2 = { 10, 8, 6, 4, 2, 1 }; // используется список инициализаторов для инициализации массива vector&amp;lt;int&amp;gt; array3 { 10, 8, 6, 4, 2, 1 }; // используется uniform-инициализация для инициализации массива (начиная с C++11) Подобно массивам доступ к элементам может выполняться как через оператор [] (который не выполняет проверку диапазона), так и через функцию at().</description>
    </item>
    
    <item>
      <title>Качество ПО</title>
      <link>https://apmath-spbu.github.io/methodology/quality/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/methodology/quality/</guid>
      <description>Основные тезисы:
Качетсво ПО имеет внешние и внутренние характеристики. К внешним характеристикам относят следующие свойства:
 корректность практичность эффективность надежность целостность адаптируемость правильность живучесть  К внутренним характеристикам можно онтести:
 удобство сопровождения гибкость портируемость возможность повторного использования удобочитаемость тестируемость понятность  Методики повышения каечтсва ПО  Целевые запактеристики качества ПО Явный контроль качества Стратегия тестирования Технические обзоры Внешний аудит  Главный закон контроля качества ПО - повышение качества системы снижает расходы на ее разработку.</description>
    </item>
    
    <item>
      <title>Конструктор</title>
      <link>https://apmath-spbu.github.io/basics/lecture4/constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture4/constructor/</guid>
      <description>Конструктор – метод класса, автоматически применяемый к каждому экземпляру (объекту) класса перед первым использованием (в случае динамического выделения памяти – после успешного выполнения операции new). Освобождение ресурсов, захваченных в конструкторе класса либо на протяжении времени жизни соответствующего экземпляра, осуществляет деструктор.
Выполнение любого конструктора состоит из двух фаз:
 Фаза явной (неявной) инициализации (обработка списка инициализации) Фаза вычислений (исполнение тела конструктора)  Конструктор не может определяться со спецификатором const. Константность и объекта устанавливается по завершении работы конструктора и снимается перед вызовом деструктора.</description>
    </item>
    
    <item>
      <title>Финальные методы и классы</title>
      <link>https://apmath-spbu.github.io/basics/lecture5/final/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture5/final/</guid>
      <description>Помимо того, что можно дополнить/изменить/скрыть функциональность существует возможность и останить иерархию как наследования, так и переопределения. Для этого существуют финальные методы/классы.
struct A { virtual void foo() { cout &amp;lt;&amp;lt; &amp;#34;A&amp;#34;; } // void bar() final; // недопустимо }; struct B : A { // И делаем финальным классом, без возможности  void foo() final { cout &amp;lt;&amp;lt; &amp;#34;B&amp;#34;; } }; struct С final : A { // C делаем финальным классом, без возможности отнаследоваться от него }; struct D : B { //void foo() { cout &amp;lt;&amp;lt; &amp;#34;D&amp;#34;; } // недопустимо, так как в B метод foo финальный }; /* struct E : C { };	// недопустимо, так как C - финальный класс */ </description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://apmath-spbu.github.io/methodology/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/methodology/git/</guid>
      <description>Основные тезисы:
Типы систем контроля версий:
 локальные централизованные распределенные  Централизованные системы контроля версий Распределенные системы контроля версий Git общие команды  clone pull add commit push branch merge cherry-pick tag blame  Материалы  Задачи по бранчеванию в Git - https://learngitbranching.js.org/  </description>
    </item>
    
    <item>
      <title>Множественное наследование</title>
      <link>https://apmath-spbu.github.io/basics/lecture5/multipleinheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture5/multipleinheritance/</guid>
      <description>Множественное наследование в ООП – это наследование от двух и более базовых классов, возможно, с различным уровнем доступа (нет никаких ограничений на количество). При множественном наследовании конструкторы базовых классов вызываются в порядке перечисления имен классов в списке базовых классов. Порядок вызова деструкторов ему прямо противоположен.
class Derived : public BaseA, protected BaseB, private BaseC { // ...  }; Виратуальное наследование При множественном наследовании возможна ситуация неоднократного включения подобъекта одного и того же базового класса в состав производного.</description>
    </item>
    
    <item>
      <title>Динамическая идентификация типов времени выполнения</title>
      <link>https://apmath-spbu.github.io/basics/lecture5/dynamiccast/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture5/dynamiccast/</guid>
      <description>Динамическая идентификация типов времени выполнения позволяет программе узнать реальный производный тип объекта, адресуемого по ссылке или по указателю на базовый класс. Реализована 2 операциями:
 dynamic_cast – поддерживает преобразование типов времени выполнения операция typeid идентифицирует реальный тип выражения  Операция dynamic_cast Встроенная унарная операция dynamic_cast языка C++ позволяет безопасно трансформировать указатель на базовый класс в указатель на производный класс:
class Alpha { }; class Beta : public Alpha { }; // .</description>
    </item>
    
  </channel>
</rss>
