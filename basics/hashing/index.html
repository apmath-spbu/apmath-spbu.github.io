<!DOCTYPE html>
<html lang="ru-ru" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="description" content="Хеш-таблица Пусть мы хотим поддерживать множество $A$ элементов - ключей, то есть уметь добавлять ключ в $A$, удалять ключ из $A$, а также искать ключ в $A$. Мы будем считать, что все ключи берутся из множества $U=\{0,1, \ldots,|U|-1\}$.
✍️ В общем случае ключами могут быть какие угодно объекты, которым можно каким-либо образом сопоставить числа (например, строки).
Если $|U|$ не очень велико, можно просто создать массив размера $|U|$ и хранить каждый ключ в ячейке с номером, равным этому ключу. Чтобы понимать, каких ключей в $A$ нет, в соответствующих ячейках будем хранить специальное значение, не равное ни одному из ключей, например, -1 . Тогда все операции можно осуществлять за $O(1)$.">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="8. Хеширование :: Краткий курс по основам программирования">
    <meta name="twitter:description" content="Хеш-таблица Пусть мы хотим поддерживать множество $A$ элементов - ключей, то есть уметь добавлять ключ в $A$, удалять ключ из $A$, а также искать ключ в $A$. Мы будем считать, что все ключи берутся из множества $U=\{0,1, \ldots,|U|-1\}$.
✍️ В общем случае ключами могут быть какие угодно объекты, которым можно каким-либо образом сопоставить числа (например, строки).
Если $|U|$ не очень велико, можно просто создать массив размера $|U|$ и хранить каждый ключ в ячейке с номером, равным этому ключу. Чтобы понимать, каких ключей в $A$ нет, в соответствующих ячейках будем хранить специальное значение, не равное ни одному из ключей, например, -1 . Тогда все операции можно осуществлять за $O(1)$.">
    <meta property="og:url" content="https://apmath-spbu.github.io/basics/hashing/index.html">
    <meta property="og:site_name" content="Краткий курс по основам программирования">
    <meta property="og:title" content="8. Хеширование :: Краткий курс по основам программирования">
    <meta property="og:description" content="Хеш-таблица Пусть мы хотим поддерживать множество $A$ элементов - ключей, то есть уметь добавлять ключ в $A$, удалять ключ из $A$, а также искать ключ в $A$. Мы будем считать, что все ключи берутся из множества $U=\{0,1, \ldots,|U|-1\}$.
✍️ В общем случае ключами могут быть какие угодно объекты, которым можно каким-либо образом сопоставить числа (например, строки).
Если $|U|$ не очень велико, можно просто создать массив размера $|U|$ и хранить каждый ключ в ячейке с номером, равным этому ключу. Чтобы понимать, каких ключей в $A$ нет, в соответствующих ячейках будем хранить специальное значение, не равное ни одному из ключей, например, -1 . Тогда все операции можно осуществлять за $O(1)$.">
    <meta property="og:locale" content="ru_ru">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Список вопросов к экзамену по курсу основы программирования СПбГУ, весенний семестр, 2024/25 учебный год">
    <meta property="article:published_time" content="2025-03-02T11:30:34+03:00">
    <meta property="article:modified_time" content="2025-03-02T11:30:34+03:00">
    <meta itemprop="name" content="8. Хеширование :: Краткий курс по основам программирования">
    <meta itemprop="description" content="Хеш-таблица Пусть мы хотим поддерживать множество $A$ элементов - ключей, то есть уметь добавлять ключ в $A$, удалять ключ из $A$, а также искать ключ в $A$. Мы будем считать, что все ключи берутся из множества $U=\{0,1, \ldots,|U|-1\}$.
✍️ В общем случае ключами могут быть какие угодно объекты, которым можно каким-либо образом сопоставить числа (например, строки).
Если $|U|$ не очень велико, можно просто создать массив размера $|U|$ и хранить каждый ключ в ячейке с номером, равным этому ключу. Чтобы понимать, каких ключей в $A$ нет, в соответствующих ячейках будем хранить специальное значение, не равное ни одному из ключей, например, -1 . Тогда все операции можно осуществлять за $O(1)$.">
    <meta itemprop="datePublished" content="2025-03-02T11:30:34+03:00">
    <meta itemprop="dateModified" content="2025-03-02T11:30:34+03:00">
    <meta itemprop="wordCount" content="2918">
    <title>8. Хеширование :: Краткий курс по основам программирования</title>
    <link href="/fonts/fontawesome/css/fontawesome-all.min.css" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/fonts/fontawesome/css/fontawesome-all.min.css" rel="stylesheet"></noscript>
    <link href="/css/perfect-scrollbar/perfect-scrollbar.min.css" rel="stylesheet">
    <link href="/css/theme.min.css" rel="stylesheet">
    <link href="/css/format-html.min.css" rel="stylesheet" id="R-format-style">
    <link href="/css/auto-complete/auto-complete.min.css" rel="stylesheet">
    <script src="/js/auto-complete/auto-complete.min.js" defer></script>
    <script src="/js/lunr/lunr.min.js" defer></script>
    <script src="/js/lunr/lunr.stemmer.support.min.js" defer></script>
    <script src="/js/lunr/lunr.multi.min.js" defer></script>
    <script src="/js/lunr/lunr.ru.min.js" defer></script>
    <script src="/js/search.min.js" defer></script>
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/basics\/hashing\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/apmath-spbu.github.io';
      window.relearn.contentLangs=['ru'];
      window.relearn.index_js_url="/searchindex.ru.js";
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // variant stuff
      window.relearn.themevariants = [ 'green' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
      // translations
      window.T_Copy_to_clipboard = `Копировать в буфер`;
      window.T_Copied_to_clipboard = `Скопировано в буфер обмена!`;
      window.T_Copy_link_to_clipboard = `Скопировать ссылку в буфер обмена`;
      window.T_Link_copied_to_clipboard = `Ссылка скопирована в буфер обмена!`;
      window.T_Reset_view = `Вид на сброс`;
      window.T_View_reset = `Посмотреть сброс!`;
      window.T_No_results_found = `Ничего не найдено для "{0}"`;
      window.T_N_results_found = `{1} результатов найдено для "{0}"`;
    </script>
  </head>
  <body class="mobile-support html" data-url="/basics/hashing/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Меню (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Оглавление (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#хеш-таблица">Хеш-таблица</a>
      <ul>
        <li><a href="#метод-цепочек">Метод цепочек</a></li>
        <li><a href="#открытая-адресация">Открытая адресация</a></li>
        <li><a href="#ассоциативный-массив">Ассоциативный массив</a></li>
      </ul>
    </li>
    <li><a href="#сортировка-киркпатрика-рейша">Сортировка Киркпатрика-Рейша</a></li>
    <li><a href="#универсальное-хеширование">Универсальное хеширование</a>
      <ul>
        <li><a href="#построение-универсального-семейства-хеш-функций">Построение универсального семейства хеш-функций</a></li>
      </ul>
    </li>
    <li><a href="#совершенное-хеширование">Совершенное хеширование</a></li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList">
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/index.html"><span itemprop="name">Краткий курс по основам программирования</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li>
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/basics/index.html"><span itemprop="name">Основы программирования. Весна 2025.</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li>
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">8. Хеширование</span><meta itemprop="position" content="3"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/apmath-spbu/apmath-spbu.hugo/tree/master/content/basics/hashing.md" rel="external" target="_blank" title="редактировать (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/basics/heap/index.html" title="7. Двоичная куча (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/basics/numerical_algos_arithmetic_comparison/index.html" title="9. Арифметика сравнений (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Еще"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable basics" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['$$', '$$']],  
      inlineMath: [['$', '$']]                  
    },
    loader:{
      load: ['ui/safe']
    },
  };
</script>

  </header>

<h1 id="8-хеширование">8. Хеширование</h1>

<h2 id="хеш-таблица">Хеш-таблица</h2>
<p>Пусть мы хотим поддерживать множество $A$ элементов - ключей, то есть уметь добавлять ключ в $A$, удалять ключ из $A$, а также искать ключ в $A$. Мы будем считать, что все ключи берутся из множества $U=\{0,1, \ldots,|U|-1\}$.</p>
<p>✍️ В общем случае ключами могут быть какие угодно объекты, которым можно каким-либо образом сопоставить числа (например, строки).</p>
<p>Если $|U|$ не очень велико, можно просто создать массив размера $|U|$ и хранить каждый ключ в ячейке с номером, равным этому ключу. Чтобы понимать, каких ключей в $A$ нет, в соответствующих ячейках будем хранить специальное значение, не равное ни одному из ключей, например, -1 . Тогда все операции можно осуществлять за $O(1)$.</p>
<p>Недостаток этого подхода в том, что он он использует $|U|$ памяти, и поэтому работает, только если множество $U$ не слишком велико. Кроме того, если в любой момент времени $|A| \leqslant n$, и $n$ намного меньше $|U|$, то большая часть массива никак не будет использоваться, что непрактично.</p>
<p>Хеш-таблица позволяет решить ту же задачу, используя $\Theta(n)$ памяти, и осуществляя все операции в среднем за $O(1)$. Идея состоит в том, чтобы использовать массив размера $m$, где $m$ намного меньше $|U|$, и ключ $x$ хранить в ячейке с номером $h(x)$, пользуясь хеш-функцией $h: U \rightarrow M=\{0,1, \ldots, m-1\}$.</p>
<p>Может случиться так, что $x \neq y$, но $h(x)=h(y)$. Такую ситуацию мы будем называть коллизией. Хеш-функцию стараются выбрать так, чтобы минимизировать число коллизий. Тем не менее, поскольку $m<|U|$, всегда найдётся пара ключей из $U$ с одинаковым значением хеш-функции, то есть какой бы хорошей ни была хеш-функция, коллизии иногда будут происходить.</p>
<h3 id="метод-цепочек">Метод цепочек</h3>
<p>Самый простой способ разрешения коллизий - в каждой ячейке массива хранить &ldquo;цепочку&rdquo; - список всех ключей, попавших в эту ячейку. Этот список можно реализовывать как с помощью связного списка, так и с помощью динамического массива, или даже ещё одной внутренней хеш-таблицы (чуть позже мы увидим пример, когда именно такой способ оказывается полезен).</p>
<div class="highlight wrap-code" dir="auto"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>int<span style="color:#f92672">&gt;</span> T[m] <span style="color:#75715e"># хеш-таблица</span>
</span></span><span style="display:flex;"><span>find(x): <span style="color:#75715e"># возвращает True, если x лежит в хеш-таблице</span>
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> h(x)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.</span><span style="color:#f92672">.</span>(T[p]<span style="color:#f92672">.</span>size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> T[p][i] <span style="color:#f92672">==</span> x:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>insert(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> find(x):
</span></span><span style="display:flex;"><span>        T[h(x)]<span style="color:#f92672">.</span>push_back(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>delete(x):
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> h(x)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.</span><span style="color:#f92672">.</span>(T[p]<span style="color:#f92672">.</span>size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> T[p][i] <span style="color:#f92672">==</span> x:
</span></span><span style="display:flex;"><span>            swap(T[p][i], T[p]<span style="color:#f92672">.</span>back())
</span></span><span style="display:flex;"><span>            T[p]<span style="color:#f92672">.</span>pop_back()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>Все операции работают за время, пропорциональное длине списка в соответствующей ячейке, то есть за $O(|T[h(x)]|+1)$. Если ключи распределены по таблице равномерно, то есть в каждом списке оказалось примерно $\frac{n}{m}$ элементов, то операции будут работать в среднем за $O\left(\frac{n}{m}+1\right)$, то есть за $O(1)$ при $m=\Omega(n)$ (мы докажем подобное утверждение более формально, когда будем рассматривать технику универсального хеширования).</p>
<p>Как добиться равномерного распределения? Подобрать &ldquo;хорошую&rdquo; хеш-функцию. Иногда это можно сделать, пользуясь информацией о том, с какими ключами придётся работать.</p>
<p>Так, если известно, что ключи выбираются из множества $U$ случайно равновероятно, и $|U|$ делится на $m$, то подойдёт хеш-функция $h(x)=x \bmod m$ : каждый ключ попадёт в каждую ячейку таблицы с равной вероятностью.</p>
<p>На практике часто используют хеш-функцию $h(x)=x \bmod m$, даже если о ключах, с которыми придётся работать, ничего не известно. При этом $m$ обычно стараются выбирать простым.</p>
<h3 id="открытая-адресация">Открытая адресация</h3>
<p>Поговорим о ещё одном способе разрешения коллизий. В хеш-таблицах с открытой адресацией в каждой ячейке хранится не более одного ключа, а при поиске ключа ячейки проверяются в некотором порядке, пока не найдётся этот ключ или пустая ячейка. Этот порядок, конечно же, будет зависеть от того, какой ключ мы ищем. Поскольку в каждой ячейке хранится не более одного ключа, в таблице размера $m$ не может храниться больше $m$ ключей.</p>
<p>Более формально, теперь мы будем работать с хеш-функцией от двух аргументов $h: U \times\{0, \ldots, m-1\} \rightarrow\{0, \ldots, m-1\}$, и при поиске $x$ перебирать ячейки в порядке $h(x, 0), h(x, 1), \ldots, h(x, m-1)$. При этом мы будем требовать, чтобы эта последовательность (будем называть её последовательностью проб) была перестановкой чисел от 0 до $m-1$ (чтобы не проверять одну ячейку несколько раз, и чтобы рано или поздно проверить каждую ячейку).</p>
<p>Последовательность проб чаще всего строят одним из следующих трёх способов (здесь $h^{\prime}, h_{1}, h_{2}: U \rightarrow\{0, \ldots, m-1\}$ - вспомогательные хеш-функции):</p>
<ul>
<li><strong>Линейное пробирование.</strong> $h(x, i)=\left(h^{\prime}(x)+c \cdot i\right) \bmod m$. Обычно используют $c=1$.</li>
<li><strong>Квадратичное пробирование.</strong> $h(x, i)=\left(h^{\prime}(x)+c_{1} \cdot i+c_{2} \cdot i^{2}\right) \bmod m$.</li>
<li><strong>Двойное хеширование.</strong> $h(x, i)=\left(h_{1}(x)+i \cdot h_{2}(x)\right) \bmod m$.</li>
</ul>
<p>При этом $c$ в первом способе и $h_{2}(x)$ в третьем должны быть взаимно просты с $m$ (чтобы последовательность пробегала все ячейки). Во втором способе по тем же причинам тоже подойдут не все $c_{1}, c_{2}$.</p>
<p>Линейное пробирование самое простое и имеет наименьшую константу во времени работы, но страдает от кластеризации: блоки из лежащих в таблице подряд ключей со временем становятся всё больше и больше (потому что всё больше и больше становится вероятность попасть в такой блок).</p>
<p>Двойное хеширование отличается тем, что может дать $\Theta\left(m^{2}\right)$ различных последовательностей (в первых двух способах вся последовательность проб однозначно определяется по $h^{\prime}(x)$, поэтому всего возможно $\Theta(m)$ различных последовательностей), поэтому менее подвержено кластеризации. Квадратичное пробирование - некий компромисс между линейным пробированием и двойным хешированием.</p>
<div class="highlight wrap-code" dir="auto"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-PY" data-lang="PY"><span style="display:flex;"><span>int T[m] <span style="color:#75715e"># Хеш-таблица</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># считаем, что ключи - неотрицательные целые числа,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># в пустых ячейках лежит -1</span>
</span></span><span style="display:flex;"><span>getIndex(x): <span style="color:#75715e"># возвращает индекс ячейки, в которой лежит x,</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># или индекс первой встретившейся пустой ячейки</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.</span><span style="color:#f92672">.</span>(m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> h(x, i)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> T[p] <span style="color:#f92672">==</span> x <span style="color:#f92672">or</span> T[p] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> p
</span></span><span style="display:flex;"><span>    error <span style="color:#e6db74">&#34;Hash table is full&#34;</span>
</span></span><span style="display:flex;"><span>find(x): <span style="color:#75715e"># возвращает True, если x лежит в хеш-таблице</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> T[getIndex(x)] <span style="color:#f92672">==</span> x
</span></span><span style="display:flex;"><span>insert(x):
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> getIndex(x)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> T[p] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#75715e"># x уже есть в таблице</span>
</span></span><span style="display:flex;"><span>    T[p] <span style="color:#f92672">=</span> x</span></span></code></pre></td></tr></table>
</div>
</div>
<p>Удалить ключ из хеш-таблицы теперь не так просто. Если просто пометить ячейку, где лежал ключ, как свободную, то поиск других ключей может перестать работать корректно (потому что при вставке другого ключа мы могли проходить через эту ячейку при поиске свободного места). Можно при удалении специальным образом помечать ячейку и пропускать её при дальнейшей работе с таблицей, но такую ячейку никогда нельзя будет переиспользовать.</p>
<div class="highlight wrap-code" dir="auto"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>delete(x):
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> getIndex(x)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> T[p] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        T[p] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> <span style="color:#75715e"># getIndex всегда будет пропускать такую ячейку</span></span></span></code></pre></td></tr></table>
</div>
</div>
$$
1+\alpha(1+\alpha(1+\alpha(1+\cdots))) \leqslant \frac{1}{1-\alpha}
$$<p>Мы эвристически оценили время работы операций в среднем как $O\left(\frac{1}{1-\alpha}\right)$. На практике хеш-таблицы с открытой адресацией действительно работают быстро, пока $\alpha$ достаточно далеко от единицы. Когда $\alpha$ приближается к единице (скажем, когда $\alpha>\frac{2}{3}$ ), можно построить новую таблицу вдвое большего размера, и перенести все элементы в неё (удалённые элементы при этом, конечно, переносить не надо).</p>
<h3 id="ассоциативный-массив">Ассоциативный массив</h3>
<p>В хеш-таблице можно хранить не просто ключи, а пары (ключ, значение). Получится ассоциативный массив - массив с произвольными индексами.</p>
<p>В С++ есть встроенные реализации хеш-таблицы и ассоциативного массива - это <a href="https://en.cppreference.com/w/cpp/container/unordered_set" rel="external" target="_blank">std::unordered_set</a>, <a href="https://en.cppreference.com/w/cpp/container/unordered_map" rel="external" target="_blank">std::unordered_map</a>.</p>
<p>Отметим, что множество ключей хеш-таблицы (и реализации ассоциативного массива через хеш-таблицу) никак не упорядочено.</p>
<p>В С++ есть и реализации упорядоченного множества и ассоциативного массива с упорядоченными ключами - <a href="https://en.cppreference.com/w/cpp/container/set" rel="external" target="_blank">std::set</a>, <a href="https://en.cppreference.com/w/cpp/container/map" rel="external" target="_blank">std::map</a>. Эти структуры позволяют совершать больше различных операций (например, находить следующий по значению ключ). Однако они устроены сильно сложнее (мы поговорим об их устройстве позже), а операции работают медленнее: даже поиск ключа требует в худшем случае $\Theta(\log n)$ времени.</p>
<h2 id="сортировка-киркпатрика-рейша">Сортировка Киркпатрика-Рейша</h2>
<p>С помощью хеш-таблицы можно соптимизировать поразрядную сортировку, улучшив время работы до $O(n \log \log C)$ на массиве из $n$ целых чисел от 0 до $C-1$.</p>
<p>Алгоритм (Kirkpatrick, Reisch, 1984) выглядит следующим образом: пусть $C=2^{2^{k}}$ (если надо, округлим $C$ вверх до ближайшего числа такого вида, при этом $\log \log C$ увеличится не более, чем на один). Если $C \leqslant n$, просто отсортируем числа подсчётом за $O(n)$, иначе представим каждое число в $\sqrt{C}$-ичной системе счисления; при этом каждое число будет состоять из двух $2^{k-1}$-битных цифр ( $\sqrt{C}=2^{2^{k-1}}$ ). Осталось отсортировать числа по старшей цифре, а при равенстве по младшей рекурсивными вызовами.</p>
<p>Хеш-таблицы (точнее, ассоциативные массивы) нужны, чтобы сгруппировать числа в блоки с равной старшей цифрой.</p>
<div class="highlight wrap-code" dir="auto"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>sort(vector<span style="color:#f92672">&lt;</span>int<span style="color:#f92672">&gt;</span> a, int k):
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span>size()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> k):
</span></span><span style="display:flex;"><span>        countingSort(a)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>int<span style="color:#f92672">&gt;</span> l <span style="color:#75715e"># сюда запишем все встретившиеся старшие цифры</span>
</span></span><span style="display:flex;"><span>    unordered_map<span style="color:#f92672">&lt;</span>int, vector<span style="color:#f92672">&lt;</span>int<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> t
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ассоциативный массив: в t[x] будем хранить список всех таких у,</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># что a[i] = x * 2 ** (2 ** (k - 1)) + y для некоторого i</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.</span><span style="color:#f92672">.</span>(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">/</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))) <span style="color:#75715e"># x - старшие 2 ** (k - 1) 6ит a[i]</span>
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">%</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))) <span style="color:#75715e"># y - младшиие 2 ** (k - 1) бит а[i]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> t<span style="color:#f92672">.</span>find(x) <span style="color:#f92672">==</span> t<span style="color:#f92672">.</span>end(): <span style="color:#75715e"># x встретилось впервые</span>
</span></span><span style="display:flex;"><span>            l<span style="color:#f92672">.</span>push_back(x)
</span></span><span style="display:flex;"><span>        t[x]<span style="color:#f92672">.</span>push_back(y)
</span></span><span style="display:flex;"><span>    sort(l, k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e"># отсортировали старшие цифры</span>
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">.</span>clear()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (x <span style="color:#f92672">in</span> l): <span style="color:#75715e"># перебираем старшие цифры в порядке возрастания</span>
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> t[x]
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> maxElementIndex(r) <span style="color:#75715e"># найдём индекс максимального элемента в r</span>
</span></span><span style="display:flex;"><span>        rmax <span style="color:#f92672">=</span> r[i]
</span></span><span style="display:flex;"><span>        swap(r[i], r<span style="color:#f92672">.</span>back())
</span></span><span style="display:flex;"><span>        r<span style="color:#f92672">.</span>pop_back()
</span></span><span style="display:flex;"><span>        sort(r, k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e"># отсортировали все младшие цифры, кроме максимальной</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (y <span style="color:#f92672">in</span> r):
</span></span><span style="display:flex;"><span>            a<span style="color:#f92672">.</span>push_back(x <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">+</span> y)
</span></span><span style="display:flex;"><span>        a<span style="color:#f92672">.</span>push_back(x <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> (k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">+</span> rmax)</span></span></code></pre></td></tr></table>
</div>
</div>
<p>Получаем рекуррентное соотношение</p>
$$
T(n)=\Theta(n)+T(|l|)+\sum_{x \in l} T(|t[x]|-1)
$$<p>Заметим, что</p>
$$
|l|+\sum_{x \in l}(|t[x]|-1)=|l|-|l|+\sum_{x \in l}|t[x]|=n,
$$<p>то есть на каждом уровне рекурсии суммарный размер подзадач равен $n$. При этом глубина рекурсии не превышает $k$, значит суммарно на всех уровнях совершено $O(k n)=$ $O(n \log \log C)$ действий. Отметим, что это оценка времени работы в среднем, поскольку мы используем хеш-таблицы.</p>
<p>На практике из-за большой константы во времени работы хеш-таблиц алгоритм как правило оказывается не быстрее обычных алгоритмов сортировки.</p>
<p>✍️ На похожей идее основано дерево ван Эмде Боаса (van Emde Boas, 1975), позволяющее делать те же операции, что и двоичная куча, на целых числах от 0 до $C-1$ в среднем за $O(\log \log C)$. На практике оно практически не используется по тем же причинам</p>
<h2 id="универсальное-хеширование">Универсальное хеширование</h2>
<p>Можно ли раз и навсегда выбрать для хеш-таблицы фиксированную хеш-функцию $h: U \rightarrow M$, которая будет хорошо работать на любых входных данных? Нет: поскольку $|U|>|M|$, всегда найдутся $\lceil|U| /|M|\rceil$ ключей с одинаковым значением хеш-функции (причём отношение $|U| /|M|$, как правило, достаточно велико). Тогда, если в запросах будет встречаться много таких ключей (например, если злоумышленник, знающий хеш-функцию, будет специально посылать такие запросы), эти запросы будут обрабатываться долго.</p>
<p>Эту проблему можно решить следующим образом: до начала работы хеш-таблицы выберем хеш-функцию случайно из некоторого семейства. Если правильно подобрать семейство, запросы по-прежнему будут обрабатываться в среднем быстро, вне зависимости от того, какие ключи подаются на вход.</p>

<details open class=" box cstyle notices def">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-rainbow"></i> 
    Определение
  </summary>
  <div class="box-content">
<p>Семейство $\mathcal{H}$ хеш-функций, действующих из множества $U$ во множество $M=\{0,1, \ldots, m-1\}$, называется универсальным, если для любой пары различных ключей $k, l \in U$ количество таких хеш-функций $h \in \mathcal{H}$, что $h(k)=h(l)$, не превосходит $\frac{|\mathcal{H}|}{m}$.</p>
  </div>
</details>

<details open class=" box cstyle notices theorem">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-shapes"></i> 
    Теорема Универсальное хеширование
  </summary>
  <div class="box-content">
<p>Пусть хеш-функция $h \in \mathcal{H}, h: U \rightarrow\{0,1, \ldots, m-1\}$ была случайно выбрана из универсального семейства $\mathcal{H}$, и использована при работе хеш-таблицы размера $m$. Пусть в хеш-таблицу уже были добавлены $n$ ключей $l_{1}, \ldots, l_{n}$, коллизии разрешались методом цепочек. Тогда для любого ключа $k \in U$ математическое ожидание длины списка в ячейке с индексом $h(k)$ не превосходит $1+\frac{n}{m}$.

<details open class=" box cstyle notices prove expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    <i class="fa-fw fas fa-lock-open"></i> 
    Доказательство
  </summary>
  <div class="box-content">
<p>Для каждой пары ключей $a, b \in U$ введём величину $\chi(h, a, b)$, равную единице, если $h(a)=h(b)$, и нулю иначе. $\chi(h, a, a)=1$ для любой $h$. При этом для $a \neq b$ математическое ожидание $\chi(h, a, b)$ не превосходит $\frac{1}{m}$ по определению универсального семейства:</p>
$$
\mathbb{E}(\chi(h, a, b))=\frac{1}{|\mathcal{H}|} \sum_{h \in \mathcal{H}} \chi(h, a, b) \leqslant \frac{1}{|\mathcal{H}|} \cdot \frac{|\mathcal{H}|}{m}=\frac{1}{m}
$$<p>Обозначим $L=\left\{l_{1}, \ldots, l_{n}\right\}$. Математическое ожидание длины списка в ячейке с индексом $h(k)$ равняется</p>
$$
\mathbb{E}\left(\sum_{l \in L} \chi(h, k, l)\right)=\sum_{l \in L} \mathbb{E}(\chi(h, k, l)) \leqslant 1+\sum_{l \in L \backslash\{k\}} \mathbb{E}(\chi(h, k, l)) \leqslant 1+\frac{n}{m}
$$
  </div>
</details></p>
  </div>
</details>

<details open class=" box cstyle notices corollar">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-chart-gantt"></i> 
    Следствие
  </summary>
  <div class="box-content">
<p>Пусть хеш-таблица размера $m$ использует технику универсального хеширования и метод цепочек для разрешения коллизий. Математическое ожидание суммарного времени работы $k$ операций $\operatorname{insert}$, $\operatorname{find}$, $\operatorname{delete}$, среди которых $O(m)$ операций $\operatorname{insert}$, есть $\Theta(k)$.

<details open class=" box cstyle notices prove expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    <i class="fa-fw fas fa-lock-open"></i> 
    Доказательство
  </summary>
  <div class="box-content">
<p>В любой момент времени в таблице лежат не более $O(m)$ элементов. Время работы любой операции не превосходит времени вычисления хеш-функции (которое мы считаем константным) и времени прохода по списку в ячейке с индексом, равным значению хеш-функции. По предыдущей теореме, математическое ожидание времени выполнения каждой операции не превосходит $O\left(1+\frac{O(m)}{m}\right)=O(1)$. Тогда математическое ожидание суммарного времени работы всех операций не превосходит $O(k)$, то есть равняется $\Theta(k)$.</p>
  </div>
</details></p>
  </div>
</details>
<p>Ещё раз отметим, что теорема и следствие выполняются для любых последовательностей запросов; математическое ожидание берётся не по входным данным, а по случайному выбору хеш-функции.</p>
<h3 id="построение-универсального-семейства-хеш-функций">Построение универсального семейства хеш-функций</h3>
<p>Построим универсальное семейство хеш-функций для чисел, влезающих в машинное слово (считаем, что арифметические операции над числами выполняются за $O(1)$ ).</p>

<details open class=" box cstyle notices theorem">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-shapes"></i> 
    Теорема
  </summary>
  <div class="box-content">
<p>Пусть $p$ - такое простое, что $U \subset\{0,1, \ldots, p-1\}$; пусть $m < p$. Для любых целых $1 \leqslant a < p, 0 \leqslant b < p$ определим хеш-функцию</p>
$$
h_{a, b}(k)=((a k+b) \bmod p) \bmod m
$$<p>Тогда семейство хеш-функций</p>
$$
\mathcal{H}_{p, m}=\left\{h_{a, b}: 1 \leqslant a < p, 0 \leqslant b < p\right\}
$$<p>является универсальным.</p>

<details open class=" box cstyle notices prove expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    <i class="fa-fw fas fa-lock-open"></i> 
    Доказательство
  </summary>
  <div class="box-content">
<p>Пусть $k \neq l$ - два различных ключа. Поймём, для каких $a, b$ верно $h_{a, b}(k)=h_{a, b}(l)$.</p>
<p>Заметим сначала, что если $r=(a k+b) \bmod p, s=(a l+b) \bmod p$, то $r \neq s$, так как $r-s \equiv a(k-l) \not \equiv 0(\bmod p)$.</p>
<p>Более того, разным парам $(a, b)$ соответствуют разные пары $(r, s)$, так как по $(r, s)$ можно восстановить $(a, b): a \equiv(r-s)(k-l)^{-1}(\bmod p), b \equiv(r-a k)(\bmod p)$.</p>
<p>Различных пар $(a, b)$ с $1 \leqslant a < p, 0 \leqslant b < p$ всего $(p-1) \cdot p$. Различных пар $(r, s)$ с $0 \leqslant r \neq s < p$ всего $p^{2}-p$, то есть столько же. Значит, мы установили взаимно однозначное соответствие между множествами пар ( $a, b$ ) и пар $(r, s)$.</p>
<p>Остаётся заметить, что $h_{a, b}(k)=h_{a, b}(l)$ тогда и только тогда, когда $r \equiv s(\bmod m)$. Для фиксированного $0 \leqslant r < p$ количество $0 \leqslant s < p$ таких, что $s \neq r$, но $r \equiv s(\bmod m)$, не превосходит $\left\lceil\frac{p}{m}\right\rceil-1 \leqslant \frac{p+m-1}{m}-1=\frac{p-1}{m}$.</p>
<p>Тогда количество хеш-функций $h_{a, b} \in \mathcal{H}_{p, m}$, для которых $h_{a, b}(k)=h_{a, b}(l)$ равняется количеству пар $(r, s)$ таких, что $0 \leqslant r \neq s < p, r \equiv s(\bmod m)$, которое не превосходит $p \cdot \frac{p-1}{m}=\frac{\left|\mathcal{H}_{p, m}\right|}{m}$.</p>
  </div>
</details>
  </div>
</details>
<h2 id="совершенное-хеширование">Совершенное хеширование</h2>
<p>Если множество используемых ключей известно заранее (например, в языках программирования множество зарезервированных слов фиксировано), то можно построить хеш-таблицу, операции в которой будут работать за $O(1)$ в худшем случае. При этом можно добиться того, чтобы хеш-таблица имела размер $O(n)$, где $n$ - число используемых ключей.</p>
<p>Снова считаем, что все ключи - целые неотрицательные числа, меньшие некоторого простого $p$. Построим хеш-таблицу с $m=n$ ячейками, при этом хеш-функцию аккуратно выберем из универсального семейства $\mathcal{H}_{p, m}$. В каждой ячейке этой таблицы вместо списка мы заведём хеш-таблицу второго уровня, причём, если в ячейку с индексом $j$ попало $n_{j}$ ключей, то внутреннюю хеш-таблицу в этой ячейке сделаем размера $m_{j}=n_{j}^{2}$. Хешфункцию для внутренней таблицы мы аккуратно выберем из универсального семейства $\mathcal{H}_{p, m_{j}}$.</p>
<p>Оказывается, можно подобрать такие хеш-функции, что во внутренних таблицах не будет коллизий, а суммарный размер всех таблиц будет оцениваться как $O(n)$.</p>
<p>В доказательстве оценок мы будем пользоваться следующим фактом (под $\mathbb{P}(A)$ имеется в виду вероятность того, что произошло событие $A$ ):</p>

<details open class=" box cstyle notices theorem">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-shapes"></i> 
    Неравенство Маркова
  </summary>
  <div class="box-content">
<p>Пусть $X$ - неотрицательная случайная величина с конечным математическим ожиданием. Тогда для любого $a>0$ верно</p>
$$
\mathbb{P}(X \geqslant a) \leqslant \frac{\mathbb{E} X}{a}
$$
<details open class=" box cstyle notices prove expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    <i class="fa-fw fas fa-lock-open"></i> 
    Доказательство
  </summary>
  <div class="box-content">
<p>Поскольку $X$ неотрицательно, $\mathbb{E} X \geqslant 0 \cdot \mathbb{P}(X < a)+a \cdot \mathbb{P}(X \geqslant a)$, откуда следует требуемое неравенство.</p>
  </div>
</details>
  </div>
</details>

<details open class=" box cstyle notices theorem">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-shapes"></i> 
    Теорема
  </summary>
  <div class="box-content">
<p>Пусть в хеш-таблице размера $m=n^{2}$ хранятся $n$ ключей, причём хешфункция $h(\cdot)$ была случайно выбрана из $\mathcal{H}_{p, m}$. Тогда с вероятностью более чем $\frac{1}{2}$ коллизий нет (все ключи хранятся в разных ячейках).

<details open class=" box cstyle notices prove expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    <i class="fa-fw fas fa-lock-open"></i> 
    Доказательство
  </summary>
  <div class="box-content">
<p>Для каждой пары различных ключей введём величину $\chi(h, a, b)$, равную единице, если $h(a)=h(b)$, и нулю иначе. Как и в теореме Универсального хеширования 8.6.1, $\mathbb{E}(\chi(h, a, b)) \leqslant \frac{1}{m}=\frac{1}{n^{2}}$. Рассмотрим случайную величину $X$ - количество коллизий. Тогда</p>
$$
\mathbb{E} X=\mathbb{E}\left(\sum_{a \neq b}(\chi(h, a, b))\right)=\sum_{a \neq b} \mathbb{E}(\chi(h, a, b)) \leqslant \frac{n(n-1)}{2} \cdot \frac{1}{n^{2}}<\frac{1}{2}
$$<p>Поскольку $X$ принимает только целые неотрицательные значения, по неравенству Маркова</p>
$$
\mathbb{P}(X>0)=\mathbb{P}(X \geqslant 1) \leqslant \mathbb{E} X<\frac{1}{2}
$$
  </div>
</details></p>
  </div>
</details>
<p>Из этой теоремы сразу же следует, что если мы можем позволить себе использовать хеш-таблицу размера $n^{2}$, то, сделав несколько попыток, мы подберём такую хеш-функцию, что все ключи попадут в разные ячейки таблицы (вероятность того, что мы не найдём такую хеш-функцию за $s$ попыток, меньше $2^{-s}$; в среднем понадобится не более двух попыток). Наша двухуровневая схема нужна, чтобы уменьшить количество используемой памяти до $O(n)$.</p>
<p>Те же рассуждения показывают, что, сделав несколько попыток, мы подберём хешфункцию без коллизий для каждой внутренней хеш-таблицы. Осталось понять, почему суммарный размер таблиц можно сделать линейным от числа ключей.</p>

<details open class=" box cstyle notices theorem">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-shapes"></i> 
    Теорема
  </summary>
  <div class="box-content">
<p>Пусть в хеш-таблице размера $m=n$ хранятся $n$ ключей, причём хешфункция $h(\cdot)$ была случайно выбрана из $\mathcal{H}_{p, m}$. Пусть в $j$-ю ячейку попало $n_{j}$ ключей, которые были помещены во внутреннюю хеш-таблицу размера $m_{j}=n_{j}^{2}$. Тогда математическое ожидание суммарного размера внутренних хеш-таблиц меньше $2 n$.

<details open class=" box cstyle notices prove expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    <i class="fa-fw fas fa-lock-open"></i> 
    Доказательство
  </summary>
  <div class="box-content">
<p>Заметим сначала, что</p>
$$
\begin{aligned}
& \mathbb{E}\left(\sum_{j=0}^{m-1} m_{j}\right)=\mathbb{E}\left(\sum_{j=0}^{m-1} n_{j}^{2}\right)=\mathbb{E}\left(\sum_{j=0}^{m-1}\left(n_{j}+2 \cdot \frac{n_{j}\left(n_{j}-1\right)}{2}\right)\right)= \\
= & \mathbb{E}\left(\sum_{j=0}^{m-1} n_{j}\right)+2 \cdot \mathbb{E}\left(\sum_{j=0}^{m-1} \frac{n_{j}\left(n_{j}-1\right)}{2}\right)=n+2 \cdot \mathbb{E}\left(\sum_{j=0}^{m-1} \frac{n_{j}\left(n_{j}-1\right)}{2}\right) .
\end{aligned}
$$<p>Теперь заметим, что $\sum_{j=0}^{m-1} \frac{n_{j}\left(n_{j}-1\right)}{2}$ - это суммарное количество случившихся коллизий. Из доказательства предыдущей теоремы мы знаем, что математическое ожидание количества коллизий не превосходит $\frac{n(n-1)}{2} \cdot \frac{1}{m}=\frac{n-1}{2}$, так как $m=n$. Получаем</p>
$$
\mathbb{E}\left(\sum_{j=0}^{m-1} m_{j}\right) \leqslant n+2 \cdot \frac{n-1}{2}=2 n-1<2 n .
$$
  </div>
</details></p>
  </div>
</details>

<details open class=" box cstyle notices corollar">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-chart-gantt"></i> 
    Следствие
  </summary>
  <div class="box-content">
<p>В предположениях теоремы суммарный размер внутренних хеш-таблиц окажется больше или равен $4 n$ с вероятностью меньше $\frac{1}{2}$.

<details open class=" box cstyle notices prove expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    <i class="fa-fw fas fa-lock-open"></i> 
    Доказательство
  </summary>
  <div class="box-content">
<p>Воспользуемся неравенством Маркова:</p>
$$
\mathbb{P}\left(\sum_{j=0}^{m-1} m_{j} \geqslant 4 n\right) \leqslant \frac{\mathbb{E}\left(\sum_{j=0}^{m-1} m_{j}\right)}{4 n}<\frac{2 n}{4 n}=\frac{1}{2}
$$
  </div>
</details></p>
  </div>
</details>
<p>Снова получаем, что за $s$ попыток с вероятностью хотя бы $1-2^{-s}$ (и не больше чем за две попытки в среднем) мы подберём такую хеш-функцию для внешней хеш-таблицы, что суммарный размер всех внутренних хеш-таблиц будет оцениваться как $O(n)$ (будет меньше $4 n$ ).</p>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2 мар. 2025 г.
  </footer>
</article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">




        </div>
        <search><form action="/search/index.html" method="get">
          <div class="searchbox default-animation">
            <button class="search-detail" type="submit" title="Поиск (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
            <label class="a11y-only" for="R-search-by">Поиск</label>
            <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Поиск...">
            <button class="search-clear" type="button" data-search-clear="" title="Очистить поиск"><i class="fas fa-times" title="Очистить поиск"></i></button>
          </div>
        </form></search>
      </div>
      <div id="R-homelinks" class="default-animation">
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-homelinks">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-headercontrols">
          <ul class="">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div class="R-sidebarmenu R-shortcutmenu-main">
          <ul class="enlarge morespace collapsible-menu">
            <li class="parent " data-nav-id="/basics/index.html"><a class="padding" href="/basics/index.html">Основы программирования. Весна 2025.</a><ul id="R-subsections-0b672522ed89c7ef2dda1a5f8d779fdb" class="collapsible-menu">
            <li class="" data-nav-id="/basics/complexity/index.html"><a class="padding" href="/basics/complexity/index.html">1. Анализ сложности алгоритмов</a></li>
            <li class="" data-nav-id="/basics/elementary_arithmetic/index.html"><a class="padding" href="/basics/elementary_arithmetic/index.html">2. Элементарная арифметика</a></li>
            <li class="" data-nav-id="/basics/recurrence_relation/index.html"><a class="padding" href="/basics/recurrence_relation/index.html">3. Рекурентные соотношения</a></li>
            <li class="" data-nav-id="/basics/basic_data_structures/index.html"><a class="padding" href="/basics/basic_data_structures/index.html">4. Базовые структуры данных</a></li>
            <li class="" data-nav-id="/basics/binary_search/index.html"><a class="padding" href="/basics/binary_search/index.html">5. Двоичный поиск</a></li>
            <li class="" data-nav-id="/basics/sorts/index.html"><a class="padding" href="/basics/sorts/index.html">6. Сортировки</a></li>
            <li class="" data-nav-id="/basics/heap/index.html"><a class="padding" href="/basics/heap/index.html">7. Двоичная куча</a></li>
            <li class="active " data-nav-id="/basics/hashing/index.html"><a class="padding" href="/basics/hashing/index.html">8. Хеширование</a></li>
            <li class="" data-nav-id="/basics/numerical_algos_arithmetic_comparison/index.html"><a class="padding" href="/basics/numerical_algos_arithmetic_comparison/index.html">9. Арифметика сравнений</a></li>
            <li class="" data-nav-id="/basics/numerical_algos_prime_test_and_factorization/index.html"><a class="padding" href="/basics/numerical_algos_prime_test_and_factorization/index.html">10. Проверка на простоту и факторизация</a></li>
            <li class="" data-nav-id="/basics/numerical_algos_cryptography/index.html"><a class="padding" href="/basics/numerical_algos_cryptography/index.html">11. Криптография</a></li>
            <li class="" data-nav-id="/basics/graph_definition/index.html"><a class="padding" href="/basics/graph_definition/index.html">12. Графы. Определения и способы хранения</a></li>
            <li class="" data-nav-id="/basics/graph_depth_search/index.html"><a class="padding" href="/basics/graph_depth_search/index.html">13. Графы. Поиск в глубину</a></li>
            <li class="" data-nav-id="/basics/graph_shortest_path_algos/index.html"><a class="padding" href="/basics/graph_shortest_path_algos/index.html">14. Графы. Алгоритмы поиска кратчайших путей</a></li>
            <li class="" data-nav-id="/basics/greedy_algorithms/index.html"><a class="padding" href="/basics/greedy_algorithms/index.html">15. Жадные алгоритмы</a></li>
            <li class="" data-nav-id="/basics/finding_the_minimum_spanning_tree/index.html"><a class="padding" href="/basics/finding_the_minimum_spanning_tree/index.html">16. Поиск минимального остовного дерева</a></li>
            <li class="alwaysopen " data-nav-id="/basics/dynamic_programming/index.html"><a class="padding" href="/basics/dynamic_programming/index.html">17. Динамическое программирование</a><ul id="R-subsections-e410e8e319c8bca77e7f56a71695086a" class="collapsible-menu"></ul></li></ul></li>
          </ul>
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-shortcuts">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div id="R-footer-margin"></div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-footercontrols">
          <ul class="">
          </ul>
        </div>
<div id="R-footer"><p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p></div>
      </div>
    </aside>
    <script src="/js/clipboard/clipboard.min.js" defer></script>
    <script src="/js/perfect-scrollbar/perfect-scrollbar.min.js" defer></script>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/js/mathjax/tex-mml-chtml.js"></script>
    <script src="/js/theme.min.js" defer></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-179019749-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-179019749-1');
</script>
  </body>
</html>
