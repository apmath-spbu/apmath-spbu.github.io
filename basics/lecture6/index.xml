<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Лекция #6 on Материалы курсов на кафедре Технологии Программирования. ПМ-ПУ</title>
    <link>https://apmath-spbu.github.io/basics/lecture6/</link>
    <description>Recent content in Лекция #6 on Материалы курсов на кафедре Технологии Программирования. ПМ-ПУ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language><atom:link href="https://apmath-spbu.github.io/basics/lecture6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Наследование. Композиция. Агрегация</title>
      <link>https://apmath-spbu.github.io/basics/lecture6/composition-aggregation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture6/composition-aggregation/</guid>
      <description>Поговорим еще немного о наследовании и их связи на конкретном примере геометрических фигур квадрата и прямоугольника. Когда мы готовы применить наследование мы должны применять принцип &amp;ldquo;is a&amp;rdquo; отношение. Геометрически квадрат — это специализация прямоугольника: все квадраты — прямоугольники, но не все прямоугольники — квадраты. Все объекты в классе «Квадрат» являются прямоугольниками, у которых длина равна ширине. Другими словами &amp;ldquo;Square is a Rectangle&amp;rdquo;, но прямоугольник не всегда является квадратом. Получаем следующую иерархию: classDiagramShape class Shape { // .</description>
    </item>
    
    <item>
      <title>Переопределение операторов</title>
      <link>https://apmath-spbu.github.io/basics/lecture6/operator-overriding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture6/operator-overriding/</guid>
      <description>Вспомним еще раз весь список операторов в C++
 Арифметические:  Унарные: (префиксные/постфиксные) + - ++ &amp;ndash; Бинарные: + - * / % += -= /= %=   Битовые:  Унарные: ~ Бинарные: &amp;amp; | ^ &amp;amp;= |= ^= &amp;raquo; &amp;laquo;   Логические:  Унарные: ! Бинарные: &amp;amp; | &amp;amp;&amp;amp; || Сравнения: == != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;=   Присваивания: = Тернарный: ?: Специальные: , . :: Скобки: [] () Оператор приведения: (type) Доступа: -&amp;gt;  Все операторы, за исключением ?</description>
    </item>
    
    <item>
      <title>Статические переменные</title>
      <link>https://apmath-spbu.github.io/basics/lecture6/static/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture6/static/</guid>
      <description>В С++ различают локальные и глобальные переменные. Глобальные переменные статичны по определению. Но в C++ можно ввести и статическую локальную переменную. Статическа локальная переменная – это глобальная переменная, доступная только в пределах функции. Время жизни – от первого вызова функции до конца программы.
#include &amp;lt;iostream&amp;gt;using namespace std; int next(int start = 0) { static int k = start; return k++; } int main() { cout &amp;lt;&amp;lt; next(5); cout &amp;lt;&amp;lt; next(4); cout &amp;lt;&amp;lt; next(3); cout &amp;lt;&amp;lt; next(2); cout &amp;lt;&amp;lt; next(1); return 0; } // 56789 Статические поля класса Статические поля класса – это глобальные переменные, определенные внутри класса.</description>
    </item>
    
    <item>
      <title>Inline и друзья</title>
      <link>https://apmath-spbu.github.io/basics/lecture6/inline-friends/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture6/inline-friends/</guid>
      <description>Inline В некоторых случаях можно дать совет компилятору встроить реализацию функции в местах вызова данной функции. Таким образом функция не будет вызвана, а ее тело будет скопировано и встравлено в место вызова, ресурсы, которые могли бы быть потрачены на вызов этой функции, — сохраняются! Минусом является лишь увеличение компилируемого кода за счет того, что встроенная функция раскрывается в коде при каждом вызове (особенно если она длинная и/или её вызывают много раз).</description>
    </item>
    
  </channel>
</rss>
