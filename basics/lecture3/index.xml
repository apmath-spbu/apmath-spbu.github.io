<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Лекция #3 on Материалы курсов на кафедре Технологии Программирования. ПМ-ПУ</title>
    <link>https://apmath-spbu.github.io/basics/lecture3/</link>
    <description>Recent content in Лекция #3 on Материалы курсов на кафедре Технологии Программирования. ПМ-ПУ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language><atom:link href="https://apmath-spbu.github.io/basics/lecture3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ссылки</title>
      <link>https://apmath-spbu.github.io/basics/lecture3/references/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture3/references/</guid>
      <description>Прежде чем описывать ссылки, давайте вспомним прошлую лекцию и распишем недостатки указателей (возможно список не полон)
Недостатки указателей  Использование указателей синтаксически загрязняет код и усложняет его понимание. (Приходится использовать операторы * и &amp;amp;) Указатели могут быть неинициализированными (что придит к некорректному исполнению кода). Указатель может быть нулевым, и его нужно прверять на равенству нулю при использовании. Арифметика указателей может сделать из корректного указателя некорректный, так как достаточно легко &amp;ldquo;промахнуться&amp;rdquo;.  Все это привело к тому, что в языке С++ появилось более дружелюбный тип данных, лишенных данных недостатков.</description>
    </item>
    
    <item>
      <title>Диначеская память</title>
      <link>https://apmath-spbu.github.io/basics/lecture3/dynamic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture3/dynamic/</guid>
      <description>Язык С++ поддерживает два основных типа выделения памяти:
 Статическое выделение памяти выполняется для статических и глобальных переменных. Память выделяется один раз (при запуске программы) и сохраняется на протяжении работы всей программы. Динамическое выделение памяти.  Как статическое выделение памяти имеют два общих свойства:
 Размер переменной/массива должен быть известен во время компиляции. Выделение и освобождение памяти происходит автоматически (когда переменная создается/уничтожается).  В некоторых случааях этого достаточно. Но в большинстве мы заранее не можем сказать какой длины будет считанная строка, или какой длины мыссив нам нужно для наших задач.</description>
    </item>
    
    <item>
      <title>Многомерные массивы</title>
      <link>https://apmath-spbu.github.io/basics/lecture3/multiplearrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture3/multiplearrays/</guid>
      <description>Помимо обычных массивов в C++ предоставляет возможность создавать и многомерные. Рассмотри на примере двумерного массива. Двумерный массив – объект данных T a[N][M], который:
 Содержит N последовательно расположенных в памяти строк по M элементов типа T в каждой; В общем и целом инициализируется аналогично одномерным массивам; По характеристикам выравнивания идентичен объекту T a[N * M], что сводит его двумерный характер к удобному умозрительному приему, упрощающему обсуждение и визуализацию порядка размещения данных  Массивы размерности больше двух считаются многомерными, при этом (N+1)-мерные массивы индуктивно определяются как линеаризованные массивы N-мерных массивов, для которых справедливо все сказанное об одно- и двумерных массивах.</description>
    </item>
    
    <item>
      <title>Const</title>
      <link>https://apmath-spbu.github.io/basics/lecture3/const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apmath-spbu.github.io/basics/lecture3/const/</guid>
      <description>В С/С++ есть простой модификатор, который делает переменную постоянной (константной).
const int value = 5; value = 8; // не получится. ощибка Порой бывают случаи, что нам нужно гарантировать, что указатель или ссылку, что мы передаем в функцию не смогу подменить на другую переменную (по ошибке или намеренно), или для гарантии того, что функция случайно не изменит значение переданного аргумента или все вместе. Для этого используются константыне модификации указателей и ссылок.</description>
    </item>
    
  </channel>
</rss>
