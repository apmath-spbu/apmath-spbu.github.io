<!DOCTYPE html>
<html lang="ru-ru" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.145.0">
    <meta name="generator" content="Relearn 7.6.1+b0c6bb558d7728ac4535a2ac677c5f47297203cc">
    <meta name="description" content="Одна из классических задач криптографии звучит следующим образом. Есть Алиса и Боб, которые хотят поговорить без свидетелей. Также есть Ева (от англ. eavesdropper), которая их подслушивает. Алиса и Боб хотят, чтобы Ева, даже если она подслушает все сообщения, не поняла, о чём был разговор.
Более формально, пусть Алиса хочет послать Бобу секретное сообщение - битовую строку $x$. Она шифрует её с помощью некоторой функции $E(\cdot)$ (от англ. encoder) и посылает Бобу зашифрованное сообщение $E(x)$. Боб использует функцию $D(\cdot)$ (от англ. decoder), чтобы восстановить исходное сообщение: $D(E(x))=x$.">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="11. Криптография :: Краткий курс по основам программирования">
    <meta name="twitter:description" content="Одна из классических задач криптографии звучит следующим образом. Есть Алиса и Боб, которые хотят поговорить без свидетелей. Также есть Ева (от англ. eavesdropper), которая их подслушивает. Алиса и Боб хотят, чтобы Ева, даже если она подслушает все сообщения, не поняла, о чём был разговор.
Более формально, пусть Алиса хочет послать Бобу секретное сообщение - битовую строку $x$. Она шифрует её с помощью некоторой функции $E(\cdot)$ (от англ. encoder) и посылает Бобу зашифрованное сообщение $E(x)$. Боб использует функцию $D(\cdot)$ (от англ. decoder), чтобы восстановить исходное сообщение: $D(E(x))=x$.">
    <meta property="og:url" content="https://apmath-spbu.github.io/basics/numerical_algos_cryptography/index.html">
    <meta property="og:site_name" content="Краткий курс по основам программирования">
    <meta property="og:title" content="11. Криптография :: Краткий курс по основам программирования">
    <meta property="og:description" content="Одна из классических задач криптографии звучит следующим образом. Есть Алиса и Боб, которые хотят поговорить без свидетелей. Также есть Ева (от англ. eavesdropper), которая их подслушивает. Алиса и Боб хотят, чтобы Ева, даже если она подслушает все сообщения, не поняла, о чём был разговор.
Более формально, пусть Алиса хочет послать Бобу секретное сообщение - битовую строку $x$. Она шифрует её с помощью некоторой функции $E(\cdot)$ (от англ. encoder) и посылает Бобу зашифрованное сообщение $E(x)$. Боб использует функцию $D(\cdot)$ (от англ. decoder), чтобы восстановить исходное сообщение: $D(E(x))=x$.">
    <meta property="og:locale" content="ru_ru">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Basics">
    <meta property="article:published_time" content="2025-03-15T19:04:57+03:00">
    <meta property="article:modified_time" content="2025-03-15T19:04:57+03:00">
    <meta itemprop="name" content="11. Криптография :: Краткий курс по основам программирования">
    <meta itemprop="description" content="Одна из классических задач криптографии звучит следующим образом. Есть Алиса и Боб, которые хотят поговорить без свидетелей. Также есть Ева (от англ. eavesdropper), которая их подслушивает. Алиса и Боб хотят, чтобы Ева, даже если она подслушает все сообщения, не поняла, о чём был разговор.
Более формально, пусть Алиса хочет послать Бобу секретное сообщение - битовую строку $x$. Она шифрует её с помощью некоторой функции $E(\cdot)$ (от англ. encoder) и посылает Бобу зашифрованное сообщение $E(x)$. Боб использует функцию $D(\cdot)$ (от англ. decoder), чтобы восстановить исходное сообщение: $D(E(x))=x$.">
    <meta itemprop="datePublished" content="2025-03-15T19:04:57+03:00">
    <meta itemprop="dateModified" content="2025-03-15T19:04:57+03:00">
    <meta itemprop="wordCount" content="998">
    <title>11. Криптография :: Краткий курс по основам программирования</title>
    <link href="/fonts/fontawesome/css/fontawesome-all.min.css?1744612242" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/fonts/fontawesome/css/fontawesome-all.min.css?1744612242" rel="stylesheet"></noscript>
    <link href="/css/perfect-scrollbar/perfect-scrollbar.min.css?1744612242" rel="stylesheet">
    <link href="/css/theme.min.css?1744612242" rel="stylesheet">
    <link href="/css/format-html.min.css?1744612242" rel="stylesheet" id="R-format-style">
    <link href="/css/auto-complete/auto-complete.min.css?1744612242" rel="stylesheet">
    <script src="/js/auto-complete/auto-complete.min.js?1744612242" defer></script>
    <script src="/js/lunr/lunr.min.js?1744612242" defer></script>
    <script src="/js/lunr/lunr.stemmer.support.min.js?1744612242" defer></script>
    <script src="/js/lunr/lunr.multi.min.js?1744612242" defer></script>
    <script src="/js/lunr/lunr.ru.min.js?1744612242" defer></script>
    <script src="/js/search.min.js?1744612242" defer></script>
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/basics\/numerical_algos_cryptography\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/apmath-spbu.github.io';
      window.relearn.contentLangs=['ru'];
      window.relearn.index_js_url="/searchindex.ru.js?1744612242";
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // variant stuff
      window.relearn.themevariants = [ 'green' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
      // translations
      window.T_Copy_to_clipboard = `Копировать в буфер`;
      window.T_Copied_to_clipboard = `Скопировано в буфер обмена!`;
      window.T_Copy_link_to_clipboard = `Скопировать ссылку в буфер обмена`;
      window.T_Link_copied_to_clipboard = `Ссылка скопирована в буфер обмена!`;
      window.T_Reset_view = `Вид на сброс`;
      window.T_View_reset = `Посмотреть сброс!`;
      window.T_No_results_found = `Ничего не найдено для "{0}"`;
      window.T_N_results_found = `{1} результатов найдено для "{0}"`;
    </script>
  </head>
  <body class="mobile-support html" data-url="/basics/numerical_algos_cryptography/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Меню (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Оглавление (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#схемы-с-закрытым-ключом">Схемы с закрытым ключом</a>
      <ul>
        <li><a href="#одноразовый-блокнот">Одноразовый блокнот</a></li>
        <li><a href="#блочные-шифры">Блочные шифры</a></li>
      </ul>
    </li>
    <li><a href="#схемы-с-открытым-ключом">Схемы с открытым ключом</a></li>
    <li><a href="#rsa">RSA</a>
      <ul>
        <li><a href="#протокол-rsa">Протокол RSA</a></li>
      </ul>
    </li>
    <li><a href="#цифровая-подпись">Цифровая подпись</a>
      <ul>
        <li><a href="#протокол-цифровой-подписи">Протокол цифровой подписи</a></li>
        <li><a href="#криптографические-хеш-функции">Криптографические хеш-функции</a></li>
      </ul>
    </li>
    <li><a href="#цифровой-сертификат">Цифровой сертификат</a></li>
    <li><a href="#протокол-диффи-хеллмана">Протокол Диффи-Хеллмана</a>
      <ul>
        <li><a href="#протокол-диффи-хеллмана-1">Протокол Диффи-Хеллмана</a></li>
      </ul>
    </li>
    <li><a href="#схема-эль-гамаля">Схема Эль-Гамаля</a>
      <ul>
        <li><a href="#протокол-эль-гамаля">Протокол Эль-Гамаля</a></li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList">
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/index.html"><span itemprop="name">Краткий курс по основам программирования</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li>
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/basics/index.html"><span itemprop="name">Basics</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li>
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">11. Криптография</span><meta itemprop="position" content="3"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/basics/numerical_algos_prime_test_and_factorization/index.html" title="10. Проверка на простоту и факторизация (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/basics/graph_definition/index.html" title="12. Графы. Определения и способы хранения (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Еще"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable basics" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['$$', '$$']],  
      inlineMath: [['$', '$']]                  
    },
    loader:{
      load: ['ui/safe']
    },
  };
</script>

  </header>

<h1 id="11-криптография">11. Криптография</h1>

<p>Одна из классических задач криптографии звучит следующим образом. Есть Алиса и Боб, которые хотят поговорить без свидетелей. Также есть Ева (от англ. eavesdropper), которая их подслушивает. Алиса и Боб хотят, чтобы Ева, даже если она подслушает все сообщения, не поняла, о чём был разговор.</p>
<p>Более формально, пусть Алиса хочет послать Бобу секретное сообщение - битовую строку $x$. Она шифрует её с помощью некоторой функции $E(\cdot)$ (от англ. encoder) и посылает Бобу зашифрованное сообщение $E(x)$. Боб использует функцию $D(\cdot)$ (от англ. decoder), чтобы восстановить исходное сообщение: $D(E(x))=x$.</p>
<p>Алиса и Боб хотят, чтобы Ева, даже подслушав $E(x)$, не получила никакой информации $\circ x$.</p>
<p>Обычно считается, что функции $E(\cdot), D(\cdot)$ вычисляются при помощи некоторых известных всем (в том числе Еве) алгоритмов, но результат вычислений зависит от некоторых параметров - ключей, известных только Алисе и Бобу. Это правило известно как принцип Керкгоффса (1883). Такая схема обмена сообщениями оказывается более гибкой: если бы вся сложность расшифровки сообщения состояла в том, что Еве неизвестны алгоритмы, которыми пользуются Алиса и Боб, то, если бы Ева откуда-то узнала эти алгоритмы, Алисе и Бобу пришлось бы с нуля договариваться о новой схеме. Если же алгоритмы известны всем, и Ева откуда-то узнаёт ключи, то достаточно поменять ключи, не меняя всю схему целиком.</p>
<h2 id="схемы-с-закрытым-ключом">Схемы с закрытым ключом</h2>
<p>Схемы с закрытым ключом (также их называют симметричными схемами) используют один и тот же ключ для шифрования и расшифровки сообщения. Такие схемы подразумевают, что Алиса и Боб заранее договариваются о некотором секретном ключе, который больше никому не известен.</p>
<h3 id="одноразовый-блокнот">Одноразовый блокнот</h3>
<p>В этом протоколе шифрования Алиса и Боб заранее встречаются и выбирают битовую строку $r$ той же длины, что и будущее сообщение $x$. Тогда шифрование сообщения состоит в побитовом сложении (xor) сообщения с ключом: $E_{r}(x)=x \oplus r$. Расшифровка устроена ровно так же: $D_{r}(x)=x \oplus r$, тогда $D_{r}\left(E_{r}(x)\right)=D_{r}(x \oplus r)=x \oplus r \oplus r=x$.</p>
<p>Если выбирать каждый бит $r$ случайно равновероятно, то все биты $E_{r}(x)=x \oplus r$ также будут равны 0 или 1 равновероятно, так что зашифрованное сообщение не даст Еве никакой информации (оно могло получиться из каждого сообщения $x$ с одной и той же вероятностью).</p>
<p>Недостаток схемы состоит в том, что таким $r$ можно воспользоваться лишь один раз: если передать два сообщения $x$ и $z$, пользуясь одним $r$, то Ева узнает $x \oplus z=(x \oplus r) \oplus(z \oplus r)$. Отсюда уже можно извлечь полезную информацию: например, если в одном из сообщений есть длинная последовательность нулей, то в $x \oplus z$ на том же месте будет просто кусок другого сообщения. Известна история проекта &ldquo;Venona&rdquo;, в рамках которого американцы во время холодной войны расшифровали многие сообщения советских разведчиков, пользуясь в том числе тем, что те иногда переиспользовали одноразовые блокноты.</p>
<p>Если Алиса и Боб хотят передать много сообщений, им нужно заранее запастись очень большим общим набором случайных бит, что непрактично.</p>
<h3 id="блочные-шифры">Блочные шифры</h3>
<p>Существует целое семейство блочных шифров, устроенных по следующей схеме: Алиса и Боб заранее выбирают секретный ключ - случайную строку $r$, но уже фиксированной длины (например, 128 бит). Сообщение делится на блоки одинаковой длины (например, тоже по 128 бит), после чего каждый из блоков шифруется одной и той же сложно устроенной обратимой функцией $E_{r}(\cdot)$.</p>
<p>Примерно так устроены, например, следующие схемы шифрования:</p>
<ul>
<li>AES (advanced encryption standard) - симметричный алгоритм шифрования, принятый в 2001 году в качестве стандарта шифрования правительством США;</li>
<li>симметричные шифры &ldquo;Кузнечик&rdquo; и &ldquo;Магма&rdquo; входят в ГОСТ 34.12-2018, принятый в качестве стандарта шифрования на территории России и СНГ.</li>
</ul>
<p>Предполагается, что несмотря на то, что один и тот же ключ используется для шифрования многих блоков, воспользоваться этим для расшифровки сообщений, как в случае с одноразовым блокнотом, не удастся, потому что функция $E_{r}(\cdot)$ устроена достаточно сложно. Одним из важных свойств такой функции является лавинный эффект при изменении одного бита $x$ должны меняться в среднем порядка половины бит $E_{r}(x)$. Если это не так, то по зашифрованным данным можно пытаться восстановить исходные сообщения с помощью статистического анализа.</p>
<h2 id="схемы-с-открытым-ключом">Схемы с открытым ключом</h2>
<p>У симметричных схем есть следующий недостаток: для того, чтобы договориться о секретном ключе, Алисе и Бобу всё равно нужно как-то поговорить без свидетелей до того, как схема начнёт ими использоваться. Непонятно, что же им делать, если они никогда раньше не общались, и Ева может читать их переписку с самого начала.</p>
<p>В 1970-е годы было открыто сразу несколько схем, позволяющих Алисе и Бобу начать общаться, не договариваясь ни о каких секретных ключах заранее. Эти схемы стали называть асимметричными, или схемами с открытым ключом.</p>
<p>В общих чертах схемы с открытым ключом устроены примерно так: для того, чтобы Алиса могла передавать Бобу сообщения, Боб выбирает два ключа - закрытый, который он не показывает никому (даже Алисе); и открытый, который он показывает Алисе или даже публикует в открытом доступе. При этом функция шифрования сообщения $E(\cdot)$ использует открытый ключ, а функция расшифровки $D(\cdot)$ - закрытый.</p>
<p>Пусть Алиса хочет отправить Бобу сообщение $x$. Алиса, пользуясь открытым ключом, отправляет Бобу зашифрованное сообщение $E(x)$. Боб, пользуясь известным только ему закрытым ключом, расшифровывает сообщение: $D(E(x))=x$.</p>
<p>Важно, чтобы только Боб мог вычислять значения функции $D(\cdot)$ за разумное время (то есть, не обладая закрытым ключом, функцию $E(\cdot)$ должно быть очень сложно обратить). Для достижения такого эффекта обычно используют задачи, которые не умеют решать быстро (например, задачу факторизации числа).</p>
<p>Заметим, что, поскольку открытый ключ доступен вообще всем, не только Алиса, а вообще кто угодно может посылать сообщения Бобу, не опасаясь, что их сможет прочитать кто-то, кроме Боба.</p>
<p>Для того, чтобы Боб мог посылать сообщения Алисе, ей тоже нужно выбрать открытый и закрытый ключи, и опубликовать открытый ключ.</p>
<h2 id="rsa">RSA</h2>
<p>Одной из первых асимметричных схем была RSA (Rivest, Shamir, Adleman, 1977). Она основана на том, что генерировать большие простые числа умеют быстро, а вот быстро раскладывать числа на простые множители не умеют.</p>
<h3 id="протокол-rsa">Протокол RSA</h3>
<ul>
<li>Боб выбирает открытый и закрытый ключи:</li>
<li>Боб выбирает два случайных больших простых числа $p \neq q$, вычисляет $n=p q$, $\varphi(n)=(p-1)(q-1)$.</li>
<li>Боб выбирает $e$, взаимно простое с $\varphi(n)$. Обычно берётся небольшое $e$, чтобы шифрование занимало меньше времени. Боб публикует пару ( $n, e$ ) - открытый ключ.</li>
<li>Боб вычисляет $d$, обратное к $e$ по модулю $\varphi(n): d e \equiv 1(\bmod \varphi(n))$. Пара $(n, d)$ - закрытый ключ Боба.</li>
<li>Алиса хочет передать Бобу сообщение $x$. Считаем, что $0 \leqslant x<n$ (иначе поделим сообщение на части и пошлём каждую отдельно). Используя открытый ключ Боба, Алиса вычисляет $y=E(x)=x^{e} \bmod n$ и передаёт его Бобу.</li>
<li>Боб получает $y$, и, пользуясь закрытым ключом, вычисляет $D(y)=y^{d} \bmod n=$ $x^{d e} \bmod n$.</li>
</ul>

<details open class=" box cstyle notices lemma">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-horse"></i> 
    Лемма
  </summary>
  <div class="box-content">
<p>Пусть $n=p q$, где $p \neq q$ - простые; $d$, $e$ - такие, что $d e \equiv 1(\bmod \varphi(n))$. Тогда $x^{d e} \equiv x(\bmod n)$ для любого $0 \leqslant x < n$.</p>

<details open class=" box cstyle notices prove expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    <i class="fa-fw fas fa-lock-open"></i> 
    Доказательство
  </summary>
  <div class="box-content">
<p>Если $x$ делится на $p$, то $x^{d e} \equiv 0 \equiv x(\bmod p)$. Иначе $x^{d e} \equiv x(\bmod p)$ по малой теореме Ферма, так как $d e-1$ делится на $\varphi(n)$, то есть и на $p-1$. Аналогично, $x^{d e} \equiv x(\bmod q)$, тогда $x^{d e}-x$ делится на $p q=n$.</p>
  </div>
</details>
  </div>
</details>
<p>✍️ Заметим, что доля $x$, не взаимно простых с $n$, не превосходит $\frac{1}{p}+\frac{1}{q}$, что для больших $p, q$ пренебрежимо мало (если мы наткнулись на такой $x$, то мы случайно факторизовали $n$ ). Для $x$, взаимно простых с $n$, утверждение леммы сразу же следует из теоремы Эйлера: $x^{d e}=x^{k \varphi(n)+1} \equiv x(\bmod n)$.</p>
<p>Предполагается, что Ева, даже если перехватит сообщение, не сможет по доступным ей $n, e, x^{e} \bmod n$ восстановить $x$ за разумное время. Можно было бы факторизовать $n$, после чего найти $d$ так же, как это сделал Боб, но факторизовать числа быстро не умеют. Также неизвестно, можно ли решить задачу восстановления $x$ по $n, e, x^{e} \bmod n$ быстрее каким-то другим способом.</p>
<p>При этом все шаги, выполняемые Алисой и Бобом, можно делать быстро (пусть $n$ состоит из $b$ бит):</p>
<ul>
<li>Быстро генерировать случайные числа заданной длины мы уже умеем;</li>
<li>$d$, обратное к $e$ по модулю $\varphi(n)$, можно вычислить с помощью расширенного алгоритма Евклида за $O\left(b^{2}\right)$;</li>
<li>шифрование и расшифровка сообщения осуществляется возведением в степень по модулю за $O(b \cdot M(b))$.</li>
</ul>
<p>Есть ещё множество тонкостей, к которым прибегают, чтобы защититься от известных методов атак на этот алгоритм шифрования (например, $d$ должно быть не слишком мало, а $p$ и $q$ должны быть большими, но не слишком близкими друг к другу; $\varphi(n)=(p-1)(q-1)$ не должно состоять только из маленьких делителей;&hellip;). Мы о них подробно говорить не будем. Отметим лишь, что в настоящее время рекомендуется использовать $n$, состоящее хотя бы из 2048 бит.</p>
<p>На практике RSA и другие схемы с открытым ключом обычно используют не для передачи самого сообщения, а для передачи ключа, который будет использоваться более быстрой схемой с закрытым ключом.</p>
<h2 id="цифровая-подпись">Цифровая подпись</h2>
<p>Пусть Бобу пришло сообщение якобы от Алисы, и он хочет убедиться, что его послала именно Алиса, а не кто-то другой. С помощью схемы с открытым ключом Алиса может &ldquo;подписать&rdquo; своё сообщение так, как это не может сделать никто другой (то есть такую подпись можно использовать как доказательство того, что автор сообщения - Алиса). Делается это следующим образом:</p>
<h3 id="протокол-цифровой-подписи">Протокол цифровой подписи</h3>
<ul>
<li>У Алисы есть открытый и закрытый ключи, она хочет послать Бобу сообщение $x$. Алиса вычисляет цифровую подпись $\sigma=D(x)$, пользуясь закрытым ключом, и посылает Бобу пару ( $x, \sigma$ ), состоящую из сообщения и подписи.</li>
<li>Боб, пользуясь открытым ключом, проверяет равенство $E(\sigma)=x$. Если равенство выполняется, сообщение действительно пришло от Алисы; если нет, то сообщение было повреждено при пересылке, либо было отправлено кем-то другим.</li>
</ul>
<p>✍️ От схемы требуется, чтобы выполнялось равенство $E(D(x))=x$ для любых $x$. Мы же ранее требовали немного другое условие: $D(E(x))=x$ для любого $x$. Но в случае, когда $D(\cdot), E(\cdot)$ - биекции (а это, как правило, так) первое следует из второго.</p>
<p>Цифровая подпись подтверждает не только то, что автор сообщения именно тот, за кого он себя выдаёт, но ещё и то, что сообщение не было изменено в процессе пересылки.</p>
<p>Можно одновременно подписывать сообщение $x$ и пересылать его в зашифрованном виде: Алиса, пользуясь своим закрытым ключом, вычисляет подпись, после чего шифрует сообщение и подпись с помощью открытого ключа Боба и отправляет зашифрованные сообщение и подпись Бобу. Боб расшифровывает сообщение и подпись с помощью своего закрытого ключа, после чего проверяет подпись с помощью открытого ключа Алисы.</p>
<h3 id="криптографические-хеш-функции">Криптографические хеш-функции</h3>
<p>На практике обычно подпись вычисляют не от самого сообщения $x$, а от $h(x)$, где $h(\cdot)$ специальная хеш-функция. Тогда получатель может вычислить ту же хеш-функцию от полученного сообщения, и проверить корректность подписи. Смысл в том, что такая подпись намного короче подписи, вычисленной от самого сообщения.</p>
<p>Что требуется от используемой хеш-функции $h(\cdot)$ ? Одно из требований звучит так: нужно, чтобы по значению $h(x)$ было сложно подобрать такое $y$, что $h(x)=h(y)$ (иначе сообщение можно будет подделать).</p>
<h2 id="цифровой-сертификат">Цифровой сертификат</h2>
<p>Есть ещё одна проблема: Ева может попытаться выдать себя за Алису, например, подменив лежащий в открытом доступе ключ Алисы на свой.</p>
<p>Эту проблему решают следующим образом: создаётся сертификат, в котором содержится информация об открытом ключе Алисы и о самой Алисе, после чего этот сертификат подписывается некоторой стороной, которой все доверяют, и открытый ключ которой всем известен. Поскольку сертификат подписан тем, кому Боб доверяет, он может быть уверен, что открытый ключ в сертификате действительно принадлежит Алисе.</p>
<p>На практике в качестве этой стороны выступают специальные центры сертификации (англ. certification authority).</p>
<h2 id="протокол-диффи-хеллмана">Протокол Диффи-Хеллмана</h2>
<p>Поговорим о схемах с открытым ключом, пользующихся отсутствием известных эффективных решений другой задачи - задачи дискретного логарифмирования. Схема Диффи-Хеллмана (Diffie, Hellman, 1976) была опубликована на год раньше RSA; она позволяет Алисе и Бобу создать общий секретный ключ, общаясь по открытым каналам (которые может подслушивать Ева).</p>
<h3 id="протокол-диффи-хеллмана-1">Протокол Диффи-Хеллмана</h3>
<ul>
<li>Алиса и Боб договариваются использовать простой модуль $p$, а также $g$ с достаточном большим $\operatorname{ord}_{p}(g)$ - порядком по модулю $p$ (минимальным $k>0$ таким, что $\left.g^{k} \equiv 1(\bmod p)\right)$.</li>
<li>Алиса выбирает случайное число $a$, а Боб выбирает случайное число $b$.</li>
<li>Алиса отправляет Бобу $x=g^{a} \bmod p$, а Боб отправляет Алисе $y=g^{b} \bmod p$.</li>
<li>Алиса вычисляет $y^{a} \bmod p=g^{a b} \bmod p$, Боб вычисляет $x^{b} \bmod p=g^{a b} \bmod p$. $g^{a b} \bmod p-$ их общий секретный ключ.</li>
</ul>
<p>✍️ Часто утверждают, что в качестве $g$ нужно брать первообразный корень по модулю p. На самом деле это не обязательное условие, достаточно, чтобы $\operatorname{ord}_{p}(g)$ имел большой простой делитель.</p>
<p>Предполагается, что по $p, g, g^{a} \bmod p, g^{b} \bmod p$ не получится найти $g^{a b} \bmod p$ за разумное время. Можно было бы решить задачу дискретного логарифмирования, то есть восстановить $a$ по $g$ и $g^{a} \bmod p$, аналогично восстановить $b$, после чего вычислить $g^{a b} \bmod p$ уже будет несложно. $a$ и $b$ выбираются достаточно большими, чтобы это нельзя было сделать простым перебором. Неизвестно, можно ли решать задачу дискретного логарифмирования быстро, и можно ли быстро найти $g^{a b} \bmod p$ каким-то другим способом.</p>
<p>$p$ и $g$ обычно выбираются сильно заранее, и считаются известными всем (в том числе Еве). Популярный вариант - использовать такое простое $p$, что $q=\frac{p-1}{2}$ тоже простое (такие $q$ называются числами Софи Жермен). Тогда в качестве $g$ можно взять случайное число из отрезка $[2, p-2]$ - порядок любого взаимно простого с $p$ числа (кроме $p-1$ ) будет не меньше $q$.</p>
<p>Все остальные шаги протокола мы умеем осуществлять быстро.
Все те же действия можно совершать не над группой остатков по модулю $p$, а над произвольной циклической группой с порождающим элементом $g$. Важно только, чтобы не было известно быстрых алгоритмов, вычисляющих дискретный логарифм в этой группе.</p>
<h2 id="схема-эль-гамаля">Схема Эль-Гамаля</h2>
<p>Ещё одна асимметричная схема для передачи шифрованных сообщений - схема ЭльГамаля (Elgamal, 1985), основанная на схеме Диффи-Хеллмана.</p>
<h3 id="протокол-эль-гамаля">Протокол Эль-Гамаля</h3>
<ul>
<li>Боб выбирает открытый и закрытый ключи:</li>
<li>Алиса и Боб заранее договариваются о таких же $p$ и $g$, как в протоколе ДиффиХеллмана.</li>
<li>Боб выбирает случайное число $a$ - закрытый ключ Боба.</li>
<li>Боб передаёт Алисе (или публикует) открытый ключ - $h=g^{a} \bmod p$.</li>
<li>Алиса хочет передать Бобу сообщение $x$. Считаем, что $x$ - элемент циклической группы, порождённой $g$ (детали того, как сопоставлять произвольному сообщению элемент группы, порождённой $g$, мы опустим). Алиса выбирает случайное число $b$, и передаёт Бобу пару $(y, z)=\left(g^{b} \bmod p, x h^{b} \bmod p\right)$.</li>
<li>Боб получает пару $(y, z)$ и, пользуясь закрытым ключом, вычисляет $y^{-a} z \bmod p=$ $g^{-a b} g^{a b} x \bmod p=x$.</li>
</ul>
<p>Как и в протоколе Диффи-Хеллмана, $a$ и $b$ выбирают достаточно большими, чтобы их нельзя было восстановить по $g^{a} \bmod p, g^{b} \bmod p$ простым перебором. Как и схема Диффи-Хеллмана, схема Эль-Гамаля безопасна в предположении того, что не существует эффективных решений задачи дискретного логарифмирования.</p>
<p>Если Алиса будет использовать одно и то же $b$ много раз, и Еве как-то удастся узнать содержание одного из старых сообщений, то она сможет перехватывать все новые сообщения (так как если Ева узнала $x$, то она может вычислить $z x^{-1} \bmod p=h^{b} \bmod p$ с с помощью чего она сможет расшифровывать все последующие сообщения, зашифрованные с помощью того же $b$ ). Поэтому важно каждый раз использовать новое $b$, в связи с чем $b$ часто называют эфемерным ключом.</p>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 15 мар. 2025 г.
  </footer>
</article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">




        </div>
        <search><form action="/search/index.html" method="get">
          <div class="searchbox default-animation">
            <button class="search-detail" type="submit" title="Поиск (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
            <label class="a11y-only" for="R-search-by">Поиск</label>
            <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Поиск...">
            <button class="search-clear" type="button" data-search-clear="" title="Очистить поиск"><i class="fas fa-times" title="Очистить поиск"></i></button>
          </div>
        </form></search>
      </div>
      <div id="R-homelinks" class="default-animation homelinks">
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-homelinks">
          <ul class="space collapsible-menu">
            <li class="" data-nav-id="/index.html"><a class="padding" href="/index.html"><i class="fa-fw fas fa-home"></i> Home</a></li>
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-headercontrols">
          <ul class="">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div class="R-sidebarmenu R-shortcutmenu-main">
          <ul class="enlarge morespace collapsible-menu">
            <li class="parent " data-nav-id="/basics/index.html"><a class="padding" href="/basics/index.html">Basics</a><ul id="R-subsections-0b672522ed89c7ef2dda1a5f8d779fdb" class="collapsible-menu">
            <li class="" data-nav-id="/basics/complexity/index.html"><a class="padding" href="/basics/complexity/index.html">1. Анализ сложности алгоритмов</a></li>
            <li class="" data-nav-id="/basics/elementary_arithmetic/index.html"><a class="padding" href="/basics/elementary_arithmetic/index.html">2. Элементарная арифметика</a></li>
            <li class="" data-nav-id="/basics/recurrence_relation/index.html"><a class="padding" href="/basics/recurrence_relation/index.html">3. Рекурентные соотношения</a></li>
            <li class="" data-nav-id="/basics/basic_data_structures/index.html"><a class="padding" href="/basics/basic_data_structures/index.html">4. Базовые структуры данных</a></li>
            <li class="" data-nav-id="/basics/binary_search/index.html"><a class="padding" href="/basics/binary_search/index.html">5. Двоичный поиск</a></li>
            <li class="" data-nav-id="/basics/sorts/index.html"><a class="padding" href="/basics/sorts/index.html">6. Сортировки</a></li>
            <li class="" data-nav-id="/basics/heap/index.html"><a class="padding" href="/basics/heap/index.html">7. Двоичная куча</a></li>
            <li class="" data-nav-id="/basics/hashing/index.html"><a class="padding" href="/basics/hashing/index.html">8. Хеширование</a></li>
            <li class="" data-nav-id="/basics/numerical_algos_arithmetic_comparison/index.html"><a class="padding" href="/basics/numerical_algos_arithmetic_comparison/index.html">9. Арифметика сравнений</a></li>
            <li class="" data-nav-id="/basics/numerical_algos_prime_test_and_factorization/index.html"><a class="padding" href="/basics/numerical_algos_prime_test_and_factorization/index.html">10. Проверка на простоту и факторизация</a></li>
            <li class="active " data-nav-id="/basics/numerical_algos_cryptography/index.html"><a class="padding" href="/basics/numerical_algos_cryptography/index.html">11. Криптография</a></li>
            <li class="" data-nav-id="/basics/graph_definition/index.html"><a class="padding" href="/basics/graph_definition/index.html">12. Графы. Определения и способы хранения</a></li>
            <li class="" data-nav-id="/basics/graph_depth_search/index.html"><a class="padding" href="/basics/graph_depth_search/index.html">13. Графы. Поиск в глубину</a></li>
            <li class="" data-nav-id="/basics/graph_shortest_path_algos/index.html"><a class="padding" href="/basics/graph_shortest_path_algos/index.html">14. Графы. Алгоритмы поиска кратчайших путей</a></li></ul></li>
          </ul>
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-shortcuts">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div id="R-footer-margin"></div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-footercontrols">
          <ul class="">
          </ul>
        </div>
<div id="R-footer"><p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p></div>
      </div>
    </aside>
    <script src="/js/clipboard/clipboard.min.js?1744612242" defer></script>
    <script src="/js/perfect-scrollbar/perfect-scrollbar.min.js?1744612242" defer></script>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/js/mathjax/tex-mml-chtml.js?1744612242"></script>
    <script src="/js/theme.min.js?1744612242" defer></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-179019749-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-179019749-1');
</script>
  </body>
</html>
