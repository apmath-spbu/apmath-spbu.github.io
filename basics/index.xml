<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Basics :: Краткий курс по основам программирования</title>
    <link>http://localhost:1313/basics/index.html</link>
    <description>This is a new chapter.</description>
    <generator>Hugo</generator>
    <language>ru-ru</language>
    <lastBuildDate>Sat, 15 Feb 2025 22:36:51 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/basics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1. Анализ сложности алгоритмов</title>
      <link>http://localhost:1313/basics/complexity/index.html</link>
      <pubDate>Sat, 15 Feb 2025 22:06:42 +0300</pubDate>
      <guid>http://localhost:1313/basics/complexity/index.html</guid>
      <description>1. Вычисление чисел Фибоначчи Последовательность чисел Фибоначчи&#xA;$$ 1,1,2,3,5,8,13,21,34,55,89, \ldots $$определяется следующим образом:&#xA;Определение 1.1.1 $F_{n}$ - $n$-ое число Фибоначчи, где $F_{0}=F_{1}=1, F_{n}=F_{n-1}+F_{n-2}, n&gt;1 .$&#xA;Числа Фибоначчи растут экспоненциально быстро:&#xA;Лемма 1.1.1 $2^{\lfloor n / 2\rfloor} \leqslant F_{n} \leqslant 2^{n}$. Доказательство Докажем утверждение по индукции.</description>
    </item>
    <item>
      <title>2. Элементарная арифметика</title>
      <link>http://localhost:1313/basics/elementary_arithmetic/index.html</link>
      <pubDate>Sat, 15 Feb 2025 22:36:51 +0300</pubDate>
      <guid>http://localhost:1313/basics/elementary_arithmetic/index.html</guid>
      <description>Современные компьютеры умеют за одну элементарную операцию складывать два 32(или 64)-битных числа. Часто (например, в криптографии) приходится работать с куда более длинными числами. Поговорим о том, как проводить с ними элементарные арифметические операции.&#xA;Для удобства будем считать, что на вход алгоритмам даются натуральные числа в двоичной записи. Мы будем работать с числами, имеющими двоичную запись длины $n$ (возможно, с ведущими нулями).&#xA;В произвольном случае можно применить соответствующий алгоритм для $n$ равного максимуму из длин чисел, а в конце определить длину записи результата применения операции (удалить ведущие нули), что потребует $O(n)$ операций и не повлияет на оценку сложности алгоритма.</description>
    </item>
  </channel>
</rss>