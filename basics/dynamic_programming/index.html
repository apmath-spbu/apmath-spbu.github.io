<!DOCTYPE html>
<html lang="ru-ru" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="description" content="Поиск кратчайшего пути в ациклическом ориентированном графе Пусть перед нами стоит задача поиска кратчайших путей от вершины $s$ до всех остальных вершин в ациклическом ориентированном графе. Конечно, можно воспользоваться одним из уже изученных алгоритмов. Есть, однако, и более простое решение с линейным временем работы.
Для любой вершины $v \neq s$ верно следующее равенство:
$$ \operatorname{dist}[v]=\min \left\{d i s t[u]&#43;w_{e}: e=(u, v) \in E\right\} $$Будем перебирать вершины в порядке топологической сортировки. Тогда все значения dist, встречающиеся в выражении справа, к моменту рассмотрения вершины $v$ уже будут найдены.">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Динамическое программирование :: Краткий курс по основам программирования">
    <meta name="twitter:description" content="Поиск кратчайшего пути в ациклическом ориентированном графе Пусть перед нами стоит задача поиска кратчайших путей от вершины $s$ до всех остальных вершин в ациклическом ориентированном графе. Конечно, можно воспользоваться одним из уже изученных алгоритмов. Есть, однако, и более простое решение с линейным временем работы.
Для любой вершины $v \neq s$ верно следующее равенство:
$$ \operatorname{dist}[v]=\min \left\{d i s t[u]&#43;w_{e}: e=(u, v) \in E\right\} $$Будем перебирать вершины в порядке топологической сортировки. Тогда все значения dist, встречающиеся в выражении справа, к моменту рассмотрения вершины $v$ уже будут найдены.">
    <meta property="og:url" content="https://apmath-spbu.github.io/basics/dynamic_programming/index.html">
    <meta property="og:site_name" content="Краткий курс по основам программирования">
    <meta property="og:title" content="Динамическое программирование :: Краткий курс по основам программирования">
    <meta property="og:description" content="Поиск кратчайшего пути в ациклическом ориентированном графе Пусть перед нами стоит задача поиска кратчайших путей от вершины $s$ до всех остальных вершин в ациклическом ориентированном графе. Конечно, можно воспользоваться одним из уже изученных алгоритмов. Есть, однако, и более простое решение с линейным временем работы.
Для любой вершины $v \neq s$ верно следующее равенство:
$$ \operatorname{dist}[v]=\min \left\{d i s t[u]&#43;w_{e}: e=(u, v) \in E\right\} $$Будем перебирать вершины в порядке топологической сортировки. Тогда все значения dist, встречающиеся в выражении справа, к моменту рассмотрения вершины $v$ уже будут найдены.">
    <meta property="og:locale" content="ru_ru">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Динамическое программирование :: Краткий курс по основам программирования">
    <meta itemprop="description" content="Поиск кратчайшего пути в ациклическом ориентированном графе Пусть перед нами стоит задача поиска кратчайших путей от вершины $s$ до всех остальных вершин в ациклическом ориентированном графе. Конечно, можно воспользоваться одним из уже изученных алгоритмов. Есть, однако, и более простое решение с линейным временем работы.
Для любой вершины $v \neq s$ верно следующее равенство:
$$ \operatorname{dist}[v]=\min \left\{d i s t[u]&#43;w_{e}: e=(u, v) \in E\right\} $$Будем перебирать вершины в порядке топологической сортировки. Тогда все значения dist, встречающиеся в выражении справа, к моменту рассмотрения вершины $v$ уже будут найдены.">
    <meta itemprop="datePublished" content="2025-04-24T15:33:10+03:00">
    <meta itemprop="dateModified" content="2025-04-24T15:33:10+03:00">
    <meta itemprop="wordCount" content="1188">
    <title>Динамическое программирование :: Краткий курс по основам программирования</title>
    <link href="/basics/dynamic_programming/index.xml" rel="alternate" type="application/rss+xml" title="Динамическое программирование :: Краткий курс по основам программирования">
    <link href="/fonts/fontawesome/css/fontawesome-all.min.css" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/fonts/fontawesome/css/fontawesome-all.min.css" rel="stylesheet"></noscript>
    <link href="/css/perfect-scrollbar/perfect-scrollbar.min.css" rel="stylesheet">
    <link href="/css/theme.min.css" rel="stylesheet">
    <link href="/css/format-html.min.css" rel="stylesheet" id="R-format-style">
    <link href="/css/auto-complete/auto-complete.min.css" rel="stylesheet">
    <script src="/js/auto-complete/auto-complete.min.js" defer></script>
    <script src="/js/lunr/lunr.min.js" defer></script>
    <script src="/js/lunr/lunr.stemmer.support.min.js" defer></script>
    <script src="/js/lunr/lunr.multi.min.js" defer></script>
    <script src="/js/lunr/lunr.ru.min.js" defer></script>
    <script src="/js/search.min.js" defer></script>
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/basics\/dynamic_programming\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/apmath-spbu.github.io';
      window.relearn.contentLangs=['ru'];
      window.relearn.index_js_url="/searchindex.ru.js";
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // variant stuff
      window.relearn.themevariants = [ 'green' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
      // translations
      window.T_Copy_to_clipboard = `Копировать в буфер`;
      window.T_Copied_to_clipboard = `Скопировано в буфер обмена!`;
      window.T_Copy_link_to_clipboard = `Скопировать ссылку в буфер обмена`;
      window.T_Link_copied_to_clipboard = `Ссылка скопирована в буфер обмена!`;
      window.T_Reset_view = `Вид на сброс`;
      window.T_View_reset = `Посмотреть сброс!`;
      window.T_No_results_found = `Ничего не найдено для "{0}"`;
      window.T_N_results_found = `{1} результатов найдено для "{0}"`;
    </script>
  </head>
  <body class="mobile-support html" data-url="/basics/dynamic_programming/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Меню (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Оглавление (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#поиск-кратчайшего-пути-в-ациклическом-ориентированном-графе">Поиск кратчайшего пути в ациклическом ориентированном графе</a></li>
    <li><a href="#метод-динамического-программирования">Метод динамического программирования</a></li>
    <li><a href="#способ-вычисления-переходов">Способ вычисления переходов</a></li>
    <li><a href="#восстановление-ответа">Восстановление ответа</a></li>
    <li><a href="#ленивое-динамическое-программирование">Ленивое динамическое программирование</a>
      <ul>
        <li><a href="#задачи">Задачи</a></li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList">
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/index.html"><span itemprop="name">Краткий курс по основам программирования</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li>
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/basics/index.html"><span itemprop="name">Основы программирования. Весна 2025.</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li>
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">17. Динамическое программирование</span><meta itemprop="position" content="3"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/apmath-spbu/apmath-spbu.hugo/tree/master/content/basics/dynamic_programming/_index.md" rel="external" target="_blank" title="редактировать (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/basics/finding_the_minimum_spanning_tree/index.html" title="Поиск минимального остовного дерева (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/basics/dynamic_programming/longest_common_subsequence/index.html" title="Наибольшая общая подпоследовательность (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Еще"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable basics" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['$$', '$$']],  
      inlineMath: [['$', '$']]                  
    },
    loader:{
      load: ['ui/safe']
    },
  };
</script>

  </header>

<h1 id="динамическое-программирование">Динамическое программирование</h1>

<h2 id="поиск-кратчайшего-пути-в-ациклическом-ориентированном-графе">Поиск кратчайшего пути в ациклическом ориентированном графе</h2>
<p>Пусть перед нами стоит задача поиска кратчайших путей от вершины $s$ до всех остальных вершин в ациклическом ориентированном графе. Конечно, можно воспользоваться одним из уже изученных алгоритмов. Есть, однако, и более простое решение с линейным временем работы.</p>
<p>Для любой вершины $v \neq s$ верно следующее равенство:</p>
$$
\operatorname{dist}[v]=\min \left\{d i s t[u]+w_{e}: e=(u, v) \in E\right\}
$$<p>Будем перебирать вершины в порядке топологической сортировки. Тогда все значения dist, встречающиеся в выражении справа, к моменту рассмотрения вершины $v$ уже будут найдены.</p>
<div class="highlight wrap-code" dir="auto"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>fill(dist, inf)
</span></span><span style="display:flex;"><span>dist[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> topOrder: <span style="color:#75715e"># рассматриваем вершины в порядке топологической сортировки</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> v <span style="color:#f92672">==</span> s:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> u, w <span style="color:#f92672">in</span> inEs[v]: <span style="color:#75715e"># inEs[v] - список входящих в v pëбep</span>
</span></span><span style="display:flex;"><span>        dist[v] <span style="color:#f92672">=</span> min(dist[v], dist[u] <span style="color:#f92672">+</span> w)</span></span></code></pre></td></tr></table>
</div>
</div>
<p>Алгоритм рассматривает подзадачи вычисления $\operatorname{dist}[v]$ для конкретной вершины $v$ в порядке увеличения сложности; каждую текущую подзадачу он сводит к нескольким подзадачам попроще, которые уже решены.</p>
<p>Заметим, что ровно таким же способом можно найти и самый длинный путь до каждой вершины; или, например, путь с максимальным произведением длин рёбер.</p>
<h2 id="метод-динамического-программирования">Метод динамического программирования</h2>
<p>Метод динамического программирования так и устроен: задача, которую нужно решить, сводится к подзадачам попроще, те - к подзадачам ещё попроще, и так далее. После этого все подзадачи решаются в правильном порядке. Какой порядок правильный? Построим на подзадачах ориентированный граф: вершины - это подзадачи, а ребро из $a$ в $b$ есть, если для решения подзадачи $b$ требуется сначала решить $a$. Тогда правильный порядок - это топологическая сортировка этого графа (разумеется, в графе на подзадачах не должно быть циклов, иначе никакой порядок не подойдёт, и решить задачу таким методом не удастся). Этот граф, как правило, не строится явно; правильный порядок часто виден сразу и не требует запуска алгоритма топологической сортировки.</p>
<p>Подзадачи мы будем называть состояниями, зависимости между состояниями (рёбра построенного выше графа) - переходами. Начальные состояния - это самые простые подзадачи, решение которых очевидно или известно заранее. В задаче выше начальное состояние $-\operatorname{dist}[s]=0$. Может быть полезно держать в голове аналогию с методом математической индукции: начальное состояние - аналог базы индукции; в методе индукции утверждение для всех остальных состояний доказывается с помощью индукционного перехода, а в методе динамического программирования значения остальных состояний вычисляются с помощью переходов.</p>
<p>На самом деле мы уже встречались с методом динамического программирования: полиномиальный алгоритм вычисления чисел Фибоначчи, алгоритмы Флойда и Форда&ndash;Беллмана, решето Эратосфена &mdash; все эти алгоритмы можно интерпретировать как динамическое программирование.</p>
<p>Проще всего с числами Фибоначчи: каждое число Фибоначчи соответствует одному состоянию; для того, чтобы узнать значение $n$-го состояния, мы пользуемся значениями $(n-1)$-го и ( $n-2$ )-го.</p>
<p>В алгоритме Флойда состояние - это тройка $(k, i, j): \operatorname{dist}[k, i, j]$ - это длина кратчайшего пути из $i$ в $j$, промежуточные вершины в котором имеют номера меньше $k$. Начальные состояния - тройки с $k=0$, для вычисления $\operatorname{dist}[k+1, i, j]$ нужны $\operatorname{dist}[k, i, j]$, $\operatorname{dist}[k, i, k]$ и $\operatorname{dist}[k, k, j]$.</p>
<p>В алгоритме Форда-Беллмана состояние - это пара $(k, v): \operatorname{dist}[k, v]$ - это длина кратчайшего пути из $s$ в $v$, состоящего из не более чем $k$ рёбер (мы изучали версию алгоритма, соптимизированную по памяти и использующую одномерный массив вместо двумерного).</p>
<p>На задачу определения простых чисел на отрезке $[1, n]$ можно смотреть так: есть переходы из числа во все числа, кратные ему; число простое, если в него нет переходов. Решето Эратосфена рассматривает только переходы из простых чисел в их кратные (потому что этого достаточно); линейная версия решета действует ещё аккуратнее, оставляя лишь по одному переходу в каждое составное число.</p>
<h2 id="способ-вычисления-переходов">Способ вычисления переходов</h2>
<p>Во многих задачах переходы можно вычислять двумя способами: &ldquo;вперёд&rdquo; и &ldquo;назад&rdquo;. Так, при поиске кратчайшего пути в ациклическом ориентированном графе вместо того, чтобы смотреть &ldquo;назад&rdquo; на входящие в вершину рёбра и пересчитывать текущее состояние через предыдущие, мы могли бы смотреть &ldquo;вперёд&rdquo; на исходящие из вершины рёбра и пересчитывать следующие состояния через текущее.</p>
<div class="highlight wrap-code" dir="auto"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>fill(dist, inf)
</span></span><span style="display:flex;"><span>dist[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> topOrder: <span style="color:#75715e"># рассматриваем вершины в порядке топологической сортировки</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> u, w <span style="color:#f92672">in</span> es[v]: <span style="color:#75715e"># es[v] - список исходящих из v рёбер</span>
</span></span><span style="display:flex;"><span>        dist[u] <span style="color:#f92672">=</span> min(dist[u], dist[v] <span style="color:#f92672">+</span> w)</span></span></code></pre></td></tr></table>
</div>
</div>
<p>Иногда оказывается, что один из способов оказывается по тем или иным причинам удобнее другого. Рассмотрим для примера такую модельную задачу: пусть $d p[1]=1$, и мы хотим для каждого $x$ от 2 до $n$ вычислить</p>
$$
d p[x]=\sum_{\substack{d < x \\ d \mid x}} d p[d] .
$$<p>Для того, чтобы считать переходы назад, нам придётся найти все делители каждого числа, что требует какой-то дополнительной работы. Считать же переходы вперёд очень просто: для фиксированного $d$ значение $d p[d]$ нужно добавить ко всем значениям состояний, кратных $d$ и не больших $n$. Их легко перебрать простым циклом. При этом суммарное время работы составит</p>
$$
O\left(n+\frac{n}{2}+\frac{n}{3}+\cdots+\frac{n}{n}\right)=O(n \log n)
$$<h2 id="восстановление-ответа">Восстановление ответа</h2>
<p>В задаче о кратчайшем пути может требоваться найти не просто длину пути, но и сам путь. Подобное может требоваться и в других задачах: нужно найти не просто число, а какой-то развёрнутый ответ. Как правило, восстановление развёрнутого ответа оказывается эквивалентным восстановлению пути из оптимальных переходов от начального состояния к конечному (мы увидим это на примерах задач). Есть два стандартных способа восстановления ответа. Первым из них мы пользовались в алгоритмах Флойда и ФордаБеллмана: нужно для каждого состояния запомнить, из какого состояния в него был сделан оптимальный переход. Тогда, пользуясь запомненными ссылками, можно откатиться от конечного состояния к начальному и восстановить весь путь.</p>
<p>Второй способ - можно ничего не запоминать, а для того, чтобы найти, откуда был сделан оптимальный переход, просто перебрать все переходы заново (то есть повторить заново всё, что делали при вычислении значения состояния, но запомнить, при рассмотрении какого перехода был найден ответ).</p>
<h2 id="ленивое-динамическое-программирование">Ленивое динамическое программирование</h2>
<p>Вычисление переходов назад можно делать лениво: напишем рекурсивную функцию, делающую рекурсивные вызовы от состояний, которые нужны для вычисления значения текущего состояния. При этом будем запоминать уже вычисленные значения, чтобы не проводить одни и те же вычисления несколько раз. Пример того, как можно лениво решать задачу поиска кратчайшего пути в ациклическом ориентированном графе:</p>
<div class="highlight wrap-code" dir="auto"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>fill(dist, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e"># -1 значит, что состояние ещё не рассматривалось</span>
</span></span><span style="display:flex;"><span>findDist(v):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> dist[v] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dist[v]
</span></span><span style="display:flex;"><span>    dist[v] <span style="color:#f92672">=</span> inf
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> u, w <span style="color:#f92672">in</span> inEs[v]: <span style="color:#75715e"># inEs[v] - список входящих в v рёбер</span>
</span></span><span style="display:flex;"><span>        dist[v] <span style="color:#f92672">=</span> min(dist[v], findDist(u) <span style="color:#f92672">+</span> w)
</span></span><span style="display:flex;"><span>dist[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.</span><span style="color:#f92672">.</span>(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>): <span style="color:#75715e"># порядок рассмотрения вершин не важен!</span>
</span></span><span style="display:flex;"><span>    findDist(v)</span></span></code></pre></td></tr></table>
</div>
</div>
<p>Как правило, ленивая версия решения работает медленнее неленивой из-за рекурсивных вызовов. Зато иногда она бывает полезна, когда нужно вычислить значение не всех состояний, а какого-либо одного. Ленивая версия не будет вычислять значения состояний, которые не используются при вычислении требуемого. Если таких состояний много, выигрыш в скорости может быть велик. Модельный пример: значения gcd от всех пар чисел от 0 до $n$ можно вычислить методом динамического программирования, пользуясь соотношением</p>
$$
\operatorname{gcd}(a, b)=\operatorname{gcd}(b, a \bmod b)
$$<p>При этом, как мы знаем, вычисление одного конкретного состояния требует вычисления лишь ещё $O(\log n)$ других состояний. Поэтому если нас интересуют лишь несколько состояний, а не все, намного эффективнее вычислить их лениво.</p>
<h3 id="задачи">Задачи</h3>
<p>Далее рассмотрим примеры задачи и их решения методом динамического программирования:
<ul class="children children-li children-sort-">
  <li class="children-title"><a href="/basics/dynamic_programming/longest_common_subsequence/index.html">Наибольшая общая подпоследовательность</a></li>
  <li class="children-title"><a href="/basics/dynamic_programming/levenshtein_distance/index.html">Расстояние Левенштейна</a></li>
  <li class="children-title"><a href="/basics/dynamic_programming/hirschbergs_algorithm/index.html">Алгоритм Хиршберга</a></li>
  <li class="children-title"><a href="/basics/dynamic_programming/longest_increasing_subsequence/index.html">Наибольшая возрастающая подпоследовательность</a></li>
  <li class="children-title"><a href="/basics/dynamic_programming/knapsack_problem/index.html">🎒 Задача о рюкзаке</a></li>
  <li class="children-title"><a href="/basics/dynamic_programming/matrices_multiplication/index.html">⬜✖️⬜ Произведение матриц</a></li>
  <li class="children-title"><a href="/basics/dynamic_programming/independent_set_of_maximum_weight_in_tree/index.html">🌳🏆 Независимое множество максимального веса в дереве</a></li>
  <li class="children-title"><a href="/basics/dynamic_programming/travelling_salesman_problem/index.html">🚗🌍 Задача коммивояжёра</a></li>
  <li class="children-title"><a href="/basics/dynamic_programming/generate_number_by_object/index.html">🔢🔄 Генерация номера по объекту и объекта по номеру</a></li>
</ul></p>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 24 апр. 2025 г.
  </footer>
</article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">




        </div>
        <search><form action="/search/index.html" method="get">
          <div class="searchbox default-animation">
            <button class="search-detail" type="submit" title="Поиск (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
            <label class="a11y-only" for="R-search-by">Поиск</label>
            <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Поиск...">
            <button class="search-clear" type="button" data-search-clear="" title="Очистить поиск"><i class="fas fa-times" title="Очистить поиск"></i></button>
          </div>
        </form></search>
      </div>
      <div id="R-homelinks" class="default-animation">
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-homelinks">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-headercontrols">
          <ul class="">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div class="R-sidebarmenu R-shortcutmenu-main">
          <ul class="enlarge morespace collapsible-menu">
            <li class="parent " data-nav-id="/basics/index.html"><a class="padding" href="/basics/index.html">Основы программирования. Весна 2025.</a><ul id="R-subsections-0b672522ed89c7ef2dda1a5f8d779fdb" class="collapsible-menu">
            <li class="" data-nav-id="/basics/complexity/index.html"><a class="padding" href="/basics/complexity/index.html">1. Анализ сложности алгоритмов</a></li>
            <li class="" data-nav-id="/basics/elementary_arithmetic/index.html"><a class="padding" href="/basics/elementary_arithmetic/index.html">2. Элементарная арифметика</a></li>
            <li class="" data-nav-id="/basics/recurrence_relation/index.html"><a class="padding" href="/basics/recurrence_relation/index.html">3. Рекурентные соотношения</a></li>
            <li class="" data-nav-id="/basics/basic_data_structures/index.html"><a class="padding" href="/basics/basic_data_structures/index.html">4. Базовые структуры данных</a></li>
            <li class="" data-nav-id="/basics/binary_search/index.html"><a class="padding" href="/basics/binary_search/index.html">5. Двоичный поиск</a></li>
            <li class="" data-nav-id="/basics/sorts/index.html"><a class="padding" href="/basics/sorts/index.html">6. Сортировки</a></li>
            <li class="" data-nav-id="/basics/heap/index.html"><a class="padding" href="/basics/heap/index.html">7. Двоичная куча</a></li>
            <li class="" data-nav-id="/basics/hashing/index.html"><a class="padding" href="/basics/hashing/index.html">8. Хеширование</a></li>
            <li class="" data-nav-id="/basics/numerical_algos_arithmetic_comparison/index.html"><a class="padding" href="/basics/numerical_algos_arithmetic_comparison/index.html">9. Арифметика сравнений</a></li>
            <li class="" data-nav-id="/basics/numerical_algos_prime_test_and_factorization/index.html"><a class="padding" href="/basics/numerical_algos_prime_test_and_factorization/index.html">10. Проверка на простоту и факторизация</a></li>
            <li class="" data-nav-id="/basics/numerical_algos_cryptography/index.html"><a class="padding" href="/basics/numerical_algos_cryptography/index.html">11. Криптография</a></li>
            <li class="" data-nav-id="/basics/graph_definition/index.html"><a class="padding" href="/basics/graph_definition/index.html">12. Графы. Определения и способы хранения</a></li>
            <li class="" data-nav-id="/basics/graph_depth_search/index.html"><a class="padding" href="/basics/graph_depth_search/index.html">13. Графы. Поиск в глубину</a></li>
            <li class="" data-nav-id="/basics/graph_shortest_path_algos/index.html"><a class="padding" href="/basics/graph_shortest_path_algos/index.html">14. Графы. Алгоритмы поиска кратчайших путей</a></li>
            <li class="" data-nav-id="/basics/greedy_algorithms/index.html"><a class="padding" href="/basics/greedy_algorithms/index.html">15. Жадные алгоритмы</a></li>
            <li class="" data-nav-id="/basics/finding_the_minimum_spanning_tree/index.html"><a class="padding" href="/basics/finding_the_minimum_spanning_tree/index.html">16. Поиск минимального остовного дерева</a></li>
            <li class="active parent alwaysopen " data-nav-id="/basics/dynamic_programming/index.html"><a class="padding" href="/basics/dynamic_programming/index.html">17. Динамическое программирование</a><ul id="R-subsections-e410e8e319c8bca77e7f56a71695086a" class="collapsible-menu">
            <li class="" data-nav-id="/basics/dynamic_programming/longest_common_subsequence/index.html"><a class="padding" href="/basics/dynamic_programming/longest_common_subsequence/index.html">Наибольшая общая подпоследовательность</a></li>
            <li class="" data-nav-id="/basics/dynamic_programming/levenshtein_distance/index.html"><a class="padding" href="/basics/dynamic_programming/levenshtein_distance/index.html">Расстояние Левенштейна</a></li>
            <li class="" data-nav-id="/basics/dynamic_programming/hirschbergs_algorithm/index.html"><a class="padding" href="/basics/dynamic_programming/hirschbergs_algorithm/index.html">Алгоритм Хиршберга</a></li>
            <li class="" data-nav-id="/basics/dynamic_programming/longest_increasing_subsequence/index.html"><a class="padding" href="/basics/dynamic_programming/longest_increasing_subsequence/index.html">Наибольшая возрастающая подпоследовательность</a></li>
            <li class="" data-nav-id="/basics/dynamic_programming/knapsack_problem/index.html"><a class="padding" href="/basics/dynamic_programming/knapsack_problem/index.html">🎒 Задача о рюкзаке</a></li>
            <li class="" data-nav-id="/basics/dynamic_programming/matrices_multiplication/index.html"><a class="padding" href="/basics/dynamic_programming/matrices_multiplication/index.html">⬜✖️⬜ Произведение матриц</a></li>
            <li class="" data-nav-id="/basics/dynamic_programming/independent_set_of_maximum_weight_in_tree/index.html"><a class="padding" href="/basics/dynamic_programming/independent_set_of_maximum_weight_in_tree/index.html">🌳🏆 Независимое множество максимального веса в дереве</a></li>
            <li class="" data-nav-id="/basics/dynamic_programming/travelling_salesman_problem/index.html"><a class="padding" href="/basics/dynamic_programming/travelling_salesman_problem/index.html">🚗🌍 Задача коммивояжёра</a></li>
            <li class="" data-nav-id="/basics/dynamic_programming/generate_number_by_object/index.html"><a class="padding" href="/basics/dynamic_programming/generate_number_by_object/index.html">🔢🔄 Генерация номера по объекту и объекта по номеру</a></li></ul></li></ul></li>
          </ul>
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-shortcuts">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div id="R-footer-margin"></div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-footercontrols">
          <ul class="">
          </ul>
        </div>
<div id="R-footer"><p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p></div>
      </div>
    </aside>
    <script src="/js/clipboard/clipboard.min.js" defer></script>
    <script src="/js/perfect-scrollbar/perfect-scrollbar.min.js" defer></script>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/js/mathjax/tex-mml-chtml.js"></script>
    <script src="/js/theme.min.js" defer></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-179019749-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-179019749-1');
</script>
  </body>
</html>
